<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: 计网 - INSOMNIA.__逃离失眠__</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="INSOMNIA.__逃离失眠__"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="INSOMNIA.__逃离失眠__"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ins0mn1a"><meta property="og:url" content="https://luffys93.github.io/"><meta property="og:site_name" content="__逃离失眠__"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://luffys93.github.io/img/LUFFY.jpg"><meta property="article:author" content="Ins0mn1a"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://luffys93.github.io/img/LUFFY.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://luffys93.github.io"},"headline":"INSOMNIA.__逃离失眠__","image":["http://luffys93.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ins0mn1a"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="INSOMNIA.__逃离失眠__" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">INSOMNIA.__逃离失眠__</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/album">Album</a><a class="navbar-item" href="/friend">Friend</a><a class="navbar-item" href="/message">Message</a><a class="navbar-item" href="/self-talking">Self-talking</a><a class="navbar-item" href="/music">Music</a><a class="navbar-item" href="/media">Media</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">计网</a></li></ul></nav></div></div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2024-04-10  <a class="commentCountImg" href="/2024/04/10/ComputerInternet/Computer-Internet3/#comment-container"><span class="display-none-class">2526ab6c63615d504eec3d0345d95161</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="2526ab6c63615d504eec3d0345d95161">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>几秒  <i class="fas fa-pencil-alt"> </i>0.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/04/10/ComputerInternet/Computer-Internet3/">Computer-Internet3</a></h1><div class="content"><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></div>  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2024-03-26  <a class="commentCountImg" href="/2024/03/26/ComputerInternet/Computer-Internet2/#comment-container"><span class="display-none-class">a5c06845f4d2420c4b139b5eec2734f4</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="a5c06845f4d2420c4b139b5eec2734f4">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>9.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/26/ComputerInternet/Computer-Internet2/">计网学习笔记（2）</a></h1><div class="content"><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="网络应用程序体系架构"><a href="#网络应用程序体系架构" class="headerlink" title="网络应用程序体系架构"></a>网络应用程序体系架构</h3><p>应用程序体系结构（application architecture）由应用程序研发者设计，规定了如何在各种端系统上组织这个应用程序。</p>
<p>目前的现代网络应用程序中一般会选择两种主流架构：==客户-服务器体系结构和对等（P2P）体系结构==</p>
<h4 id="客户-服务器体系结构"><a href="#客户-服务器体系结构" class="headerlink" title="客户-服务器体系结构"></a>客户-服务器体系结构</h4><p>服务器是一个==总是处于开机状态==的主机，它服务于来自许多其他称为<strong>客户</strong>的主机的请求。</p>
<h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><ol>
<li>两个或多个客户之间是不会直接建立通信的；</li>
<li>服务器具有固定的、周知的地址，即IP地址</li>
</ol>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>Web、FTP（文件传输协议）、Telnet（一种远程登录的协议）、电子邮件……</p>
<h5 id="其他你需要知道的"><a href="#其他你需要知道的" class="headerlink" title="其他你需要知道的"></a>其他你需要知道的</h5><p>由于使用互联网的人很多，向服务器发送的请求也很多，想要一个服务器来服务所有请求是不现实的。</p>
<p>因此，<strong>数据中心</strong>的作用就体现出来了，它配备了大量的主机，用于创建一个强大的虚拟服务器。</p>
<p>它的应用想必都见过，例如搜索引擎baidu，谷歌；Internet商务亚马逊，阿里巴巴；社交网络Facebook、推特</p>
<h4 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h4><p>这个结构对位于数据中心的专用服务器具有很少的依赖（有时候可以没有），选用这种结构的应用程序在==间断连接的主机对之间使用直接通信==，这些主机对被称为<strong>对等方</strong>。</p>
<p>:::info</p>
<p>对等方的一些解释可以参考参考上一章<strong>网络的网络</strong>部分</p>
<p>:::</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ol>
<li>==自扩展性==。P2P网络是由许多用户节点组成的，当有新的用户加入时，服务的需求虽然在增加，但是系统整体的资源和服务能力也随之扩充，能较大程度上满足用户的需求。在服务器组成的P2P网络中，只需增加服务器就能完成平滑的扩容。</li>
<li>成本低。P2P网络或者应用程序一般是不需要庞大的服务器基础设施和服务器带宽（与客户-服务器相对）</li>
</ol>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>站在操作系统的角度，进行通信的实际上是<strong>进程</strong>而并非程序。</p>
<p>在两个不同端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>来进行通信。</p>
<h4 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h4><p>网络应用程序==由成对的进程组成，这些进程通过网络相互发送报文==。</p>
<p>在这一对进程中，我们将其中之一标记为<strong>客户</strong>，另一个则是<strong>服务器</strong>了。</p>
<h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><p>在Web的应用程序中，一个客户浏览器进程与一台服务器进程相互交换报文。此时浏览器就是客户进程，Web服务器就是服务器进程。</p>
<p>在P2P文件共享系统中，文件从一个对等方进程传输到另一个对等方进程。此时下载方被标识为客户，上传方则被标识为服务器。</p>
<h5 id="如何定义客户进程与服务器进程"><a href="#如何定义客户进程与服务器进程" class="headerlink" title="如何定义客户进程与服务器进程"></a>如何定义客户进程与服务器进程</h5><p>以下定义==基于一对进程之间的通信会话场景==中</p>
<p>客户：发起通话的进程。</p>
<p>服务器：在会话开始时等待联系的进程。</p>
<h4 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h4><p>进程通过一个<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文</p>
<p>下图是两个通过因特网通信的进程之间的套接字通信</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240326223829224.png" class="" title="image-20240326223829224">

<p>在这个图中，套接字是同一台主机内应用层与运输层的接口，也是建立网络应用程序的可编程接口，因此也被称为<strong>网络应用程序接口</strong>（Application Programming Interface，API）</p>
<h5 id="应用程序开发者对套接字的管理"><a href="#应用程序开发者对套接字的管理" class="headerlink" title="应用程序开发者对套接字的管理"></a>应用程序开发者对套接字的管理</h5><p>从开发者的角度看，他们能够==控制套接字在应用层上的一切==。</p>
<p>对运输层的套接字的控制几乎是手足无措的，仅限于</p>
<ol>
<li>选择运输层协议</li>
<li>设定几个运输层参数，如最大报文长度</li>
</ol>
<h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><p>一台主机上运行的进程如果想要向另一台主机上运行的进程发送分组，则需要让接收进程有一个地址。</p>
<p>为了让接收进程被标识到，我们需要两种信息：</p>
<ol>
<li>主机的地址</li>
<li>在目的主机中指定接收进程的标识符</li>
</ol>
<p>在因特网中，==主机是由IP地址标识的==。</p>
<p>除了IP地址标识外，还需要==发送进程指定运行在接收主机的接收进程==。<strong>端口号</strong>的作用就在于此。</p>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><p>在多种多样的运输服务中，我们可以通过四个方面对应用程序服务进行分类：==可靠数据传输，吞吐量，定时，安全性==</p>
<h4 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><h5 id="如何判断"><a href="#如何判断" class="headerlink" title="如何判断"></a>如何判断</h5><p>某个服务能够做一些工作来确保某应用程序的一端发送的数据正确，且能完全地交付给该应用程序的另一端。</p>
<h5 id="其他你可能要知道的"><a href="#其他你可能要知道的" class="headerlink" title="其他你可能要知道的"></a>其他你可能要知道的</h5><ol>
<li>运输层协议能够潜在地向应用程序提供一种重要服务，这种服务是进程到进程的可靠数据传输。发送进程只要将其数据传递进套接字，就可以完全相信该数据能够无差错地到达接收进程。</li>
<li>如果运输层不提供这种服务，那大概率会被依赖这种服务的应用所排斥，但可能会被容忍丢失的应用接受，如一些多媒体应用，它的部分数据丢失一般只会导致卡顿或者音频被干扰等问题，但问题不大</li>
</ol>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><p>电子邮件，文件传输，金融应用等等</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>单位： 比特/秒 =&gt; bit/s</p>
<p><strong>带宽敏感的应用（bandwidth-sensitive application）</strong>：对吞吐量有要求的应用程序。</p>
<p><strong>弹性应用（elastic application）</strong>：说白了，能够根据带宽状态动态调整吞吐量。</p>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网为应用程序提供了两个运输层协议，分别为==UDP和TCP==。</p>
<p>附：应用程序的服务要求</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240403182749113.png" class="" title="image-20240403182749113">

<h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><p>TCP服务的模型包括：==面向连接服务和可靠数据传输服务==</p>
<p>有拥塞控制机制</p>
<h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><p>UDP仅提供最小的服务，是无连接的，因此在进行连接的时候没有握手过程，且并不能保证报文能到达接收进程，到了也有可能是乱序的</p>
<p>没有拥塞控制机制（不过有的时候，实际的端到端吞吐量可能小于选定的任意速率，因为中间链路的带宽可能会受限或者拥塞导致的）</p>
<h4 id="因特网不提供的服务"><a href="#因特网不提供的服务" class="headerlink" title="因特网不提供的服务"></a>因特网不提供的服务</h4><p>运输层协议不提供吞吐量和定时保证的服务</p>
<p>下图是因特网应用所使用的协议</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240403191549255.png" class="" title="image-20240403191549255">

<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p>
<ol>
<li>交换的报文类型，例如请求报文，响应报文</li>
<li>各种类型报文的语法，例如报文中的字段和字段的描述</li>
<li>字段的语义，即这些字段的信息的含义</li>
<li>确定一个进程什么时候，怎么发送报文，对报文响应的规则</li>
</ol>
<h3 id="这一章涉及到的网络应用"><a href="#这一章涉及到的网络应用" class="headerlink" title="这一章涉及到的网络应用"></a>这一章涉及到的网络应用</h3><p>Web、文件传输、电子邮件、目录服务、流式视频和P2P</p>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>==超文本运输协议（HyperText Transfer Protocol, HTTP）==由客户程序和服务器程序实现，它们通过交换HTTP报文进行会话。同时，HTTP定义了==这些报文的结构以及客户和服务器进行报文交换的方式==。</p>
<p>==Web页面（Web page，也叫文档）由对象组成==，而对象只是一个文件，例如HTML文件，JPEG图形等等。其中，大多数Web页面都会含有一个HTML文件和几个引用对象，其对象数量就是引用对象的数量加上HTML文件数（说白了就是N+1个对象）</p>
<p>==Web服务器==实现了HTTP的客户端（所以在Web环境中经常会交替使用”浏览器“和”客户“两种术语），也实现了HTTP的服务器端（用于存储Web对象，每个对象由URL寻址）</p>
<p>:::info</p>
<p>HTML基本文件是通过对象的URL地址来引用页面的其他对象，形如<code>http://www.example.com/path/to/sth</code>都是URL地址，其中<code>www.example.com</code>是主机名，而<code>/path/to/sth</code>是路径名</p>
<p>:::</p>
<p>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式，基本思想如下图：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240408195027295.png" class="" title="image-20240408195027295">

<ol>
<li>用户请求一个Web页面；</li>
<li>浏览器向服务器发出该页面中所包含对象的HTTP请求报文；</li>
<li>服务器接收请求并用包含这些对象的HTTP响应报文进行相应</li>
</ol>
<h4 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h4><p>HTTP服务器不保存关于用户的任何信息，这里涉及到一个关于HTTP的现象：==服务器向客户发送被请求的文件，但是不存储任何关于用户的状态信息==。</p>
<p>:::info</p>
<p>Web使用的是客户-服务器应用程序体系架构，其实看了图示也差不多可以想到了</p>
<p>:::</p>
<h3 id="非持续链接和持续链接"><a href="#非持续链接和持续链接" class="headerlink" title="非持续链接和持续链接"></a>非持续链接和持续链接</h3><h4 id="非持续连接（non-persistent-connection）"><a href="#非持续连接（non-persistent-connection）" class="headerlink" title="非持续连接（non-persistent connection）"></a>非持续连接（non-persistent connection）</h4><p>==每一个请求/响应对经过一个单独的TCP连接发送==。</p>
<p>假设URL为<code>http://www.example.com/path/to/sth</code>，且其中包含一个HTML文件和N个JPEG图形文件，我们来看看服务端向客户传送一个Web页面的步骤：</p>
<ol>
<li>HTTP客户进程在默认端口号80发起一个到服务器<code>http://www.example.com</code>的TCP连接，在客户与服务器上分别有一个套接字与该连接相关联；</li>
<li>HTTP客户经过自己的套接字向服务器发送一个HTTP请求报文，请求报文中包含了路径名<code>/path/to/sth</code>；</li>
<li>HTTP服务器进程经过自己的套接字接收该请求报文，从自己的存储器中检索对象<code>http://www.example.com/path/to/sth</code>，并将其封装到一个HTTP响应报文中；</li>
<li>HTTP服务器进程通知TCP断开TCP连接。（当然了，要等TCP确认客户已经收到完整的响应报文后，它才会断开连接）；</li>
<li>HTTP客户接收响应报文，TCP连接关闭。报文指出封装对象是一个HTML文件，客户从报文提取该文件，检查HTML文件后得到N个JPEG图形文件；</li>
<li>对每一个引用的JPEG图形对象重复前4个步骤。</li>
</ol>
<p>经过上述步骤，用户在请求该Web页面时，需要产生N+1个TCP连接</p>
<p>:::info 估算从请求到完全接收的时间</p>
<p><strong>往返时间（RTT，Round-Trip Time）</strong>：指一个短分组从客户到服务器然后再返回客户所花费的时间</p>
<p>RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延和分组处理时延。</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240408202857646.png" class="" title="image-20240408202857646">

<p>（涉及到三次握手，这个后面再说）</p>
<ol>
<li>客户请求Web页面时，会先请求建立一个TCP连接。客户向服务器发送一个TCP报文段，服务器再向客户发送一个TCP报文段来作出请求与回应；（占用一个RTT）</li>
<li>客户发送一个HTTP请求报文，报文到达服务器后，服务器就会发送响应报文（占用一个RTT）</li>
<li>后面传输文件的事情就另算了</li>
</ol>
<p>因此总的时间是<code>2RTT + 传输文件的时间</code></p>
<p>:::</p>
<h4 id="持续连接（persistent-connection）"><a href="#持续连接（persistent-connection）" class="headerlink" title="持续连接（persistent connection）"></a>持续连接（persistent connection）</h4><p>==所有的请求/响应对经过相同的TCP连接发送==。</p>
<p>相对地，在这个方式下，服务器在发送响应后并不会通知TCP关闭连接，而是保持打开状态，因此后续的请求和响应报文能通过相同的连接进行传送。</p>
<p>说白了，按照上一个连接的例子，需要用到的TCP连接数就会从N+1个变成1个</p>
<p>:::warning no-icon</p>
<p>非持续连接的缺点：</p>
<ol>
<li>该方式下，两端需要为每一个请求的对象建立和维护一个全新的连接；</li>
<li>时间占用太多，每一个对象需要花费两倍RTT来创建TCP连接和请求接收。</li>
</ol>
<p>:::</p>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>拿书上的例子说说：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240408204922748.png" class="" title="image-20240408204922748">

<p>第一行为<strong>请求行（request line）</strong>，后面的全部为<strong>首部行（header line）</strong>。</p>
<p>上图可以看出，请求行有三个部分：方法字段、URL字段和HTTP版本字段。其中，请求方法有很多：==GET、POST、DELETE、PUT、HEAD==。</p>
<p>再来看看首部行：</p>
<ol>
<li>Host：指明对象所在的主机；</li>
<li>Connection：close代表非持续连接，open代表持续连接（我记得是open吧）；</li>
<li>User-Agent：指明用户代理，也相当于指明发送请求的浏览器的类型；</li>
<li>Accept-language：表示用户想得到该对象的语言版本，服务器不存在这样的对象就发送默认语言版本</li>
</ol>
<p>下图是请求报文的通用格式：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240408205838564.png" class="" title="image-20240408205838564">

<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>接着拿书上的例子</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240408205945431.png" class="" title="image-20240408205945431">

<p>响应报文有三个部分：一个初始状态行（status line），若干个首部行（header line），实体体（entity body）</p>
<p>状态行包含三个信息：协议版本字段，状态码，状态信息</p>
<p>首部行：</p>
<ol>
<li>Connection：不赘述；</li>
<li>Date：服务器产生并发送报文的时间；</li>
<li>Server：表示报文是由某个服务器产生的；</li>
<li>Last-Modified：对象创建或者最后修改的日期和时间（这个后面再说）；</li>
<li>Content-Length：被发送对象中的字节数（应该是指实体体）；</li>
<li>Content-Type：指示实体体中的对象是什么类型的文本</li>
</ol>
<p>实体体包含了请求的对象本身（data data data……）</p>
<p>状态码有点不想说，我直接把官方的文档放这了 -&gt; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">click me</a></p>
<h3 id="用户与服务器的交互：cookie"><a href="#用户与服务器的交互：cookie" class="headerlink" title="用户与服务器的交互：cookie"></a>用户与服务器的交互：cookie</h3><p>cookie==允许站点对用户进行追踪==。</p>
<p>至于有什么用，举个例子：我访问<code>github.com</code>，但我想访问之后直接到与我有关的界面，这样就可以省去登录步骤，这个时候cookie就发挥了作用，它会保持我在这个网站的登录状态，以防一些不必要的登录。</p>
<p>不过呢，不同的浏览器cookie肯定是不同的，例如火狐登录了csdn，之后就可以省去登录步骤；IE没有登陆过，必须要登录</p>
<p>当然，咱之前玩的小游戏有需要存档的，也用到了cookie</p>
<p>下图表示cookie跟踪用户的状态</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240408211022491.png" class="" title="image-20240408211022491">

<p>根据上图可以得知，cookie技术有四个组件：</p>
<ol>
<li>HTTP响应报文的一个cookie首部行；</li>
<li>HTTP请求报文的一个cookie首部行；</li>
<li>用户端系统中保留有一个cookie文件，由用户的浏览器管理；</li>
<li>Web站点的一个后端数据库</li>
</ol>
<p>:::info</p>
<p>cookie可以标识一个用户。用户首次访问某个站点时可能需要提供一个用户标识（例如名字），在后面的对话中，浏览器会向服务器传递一个cookie首部，从而向服务器标识了这个用户。</p>
<p>因此，cookie可以在无状态HTTP之上建立一个会话层。</p>
<p>:::</p>
<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p><strong>Web缓存器（Web cache）</strong>也叫<strong>代理服务器（proxy server）</strong>，它是能够代表初始Web服务器来满足HTTP请求的网络空间实体。</p>
<p>其中，Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</p>
<p>还是拿书上的例子，看下图：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409084203339.png" class="" title="image-20240409084203339">

<p>现在客户配置的浏览器都可以使他们的HTTP请求首先指向Web缓存器，以<code>http://www.example.com/path/to/sth</code>为例，现在浏览器正在请求该对象，来看看都发生了什么：</p>
<ol>
<li>浏览器创建了一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求；</li>
<li>Web缓存器接收请求，并检查是否存在该对象的副本。如果有，Web缓存器就返回包含该对象的HTTP响应报文，没有就进行下一步；</li>
<li>Web缓存器打开一个与该对象的初始服务器（<code>www.example.com</code>）的TCP连接，然后在这个连接上发送一个关于该对象的HTTP请求。收到请求后，初始服务器向Web缓存器发送包含该对象的HTTP响应；</li>
<li>Web缓存器接收到该对象后，它在本地存储空间存储一份副本，并向客户的浏览器发送该副本的HTTP响应报文。</li>
</ol>
<p>:::danger no-icon</p>
<p>在上述步骤中，Web缓存器既是客户，也是服务器。</p>
<p>:::</p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>和普通的GET方法有点区别，<strong>条件GET方法（conditional GET）</strong>在原先GET方法的基础上加了一个功能：==检查该对象是否是最新的==</p>
<p>如果一个请求报文中用到了GET方法，并且该报文的首部行还有包含If-Modified-Since，那么这个HTTP请求报文就是一个条件GET请求报文。</p>
<p>拿书上的例子简单举例，这个倒并不是很重要：</p>
<p>某个代理缓存器代表某个浏览器向某个Web服务器发送了一个请求报文</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409092203740.png" class="" title="image-20240409092203740">

<p>然后，Web服务器发送了包含该对象的HTTP响应报文</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409092348120.png" class="" title="image-20240409092348120">

<p>可以看出，缓存器接收了报文，也在本地存储了这个对象，同时也存储了该对象的最后修改日期。</p>
<p>一段时间后，另一个用户向这个缓存器请求同一个对象，由于该对象可能已经被修改，因此在用户请求后，该缓存器会向服务器发送一个条件GET请求来进行检查：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409093035321.png" class="" title="image-20240409093035321">

<p>如果该对象没有修改，那么服务器就会向缓存器发送如下响应报文：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409093126679.png" class="" title="image-20240409093126679">

<p>报文说明对象没有修改，缓存器可以使用这个对象，最后缓存器把这个对象的副本发送给用户</p>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>这个简单说说就行，感觉不太重要</p>
<p>先上一个因特网电子邮件系统的总体概况图：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409104905295.png" class="" title="image-20240409104905295">

<p>可以看到，电子邮件分为三个主要部分：==用户代理（user agent），邮件服务器（mail server），简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）==。</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>==SMTP是因特网电子邮件中的主要协议==。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。</p>
<p>跟许多应用层协议一样，SMTP也有两个部分：运行在发送方邮件服务器的客户端，运行在接收方服务器的服务器端。</p>
<p>上一个发送端向接收端发送一个邮件的过程图：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409110157180.png" class="" title="image-20240409110157180">

<ol>
<li>Alice调用邮件代理程序并提供Bob的邮件地址，撰写报文后指示代理发送报文；</li>
<li>Alice用户代理发送报文到她的邮件服务器，报文被放在报文队列当中；</li>
<li>Alice的邮件服务器的SMTP客户端发现了报文队列中的这个报文，于是就创建一个到Bob的邮件服务器的SMTP服务器的TCP连接；</li>
<li>经过初始的SMTP握手之后，SMTP客户通过该TCP连接发送Alice的报文；</li>
<li>Bob的邮件服务器上的SMTP的服务器接收该报文，然后该邮件服务器将报文放入Bob的邮箱中；</li>
<li>Bob调用用户代理阅读报文</li>
</ol>
<p>:::info</p>
<p>几个注意的点：</p>
<ol>
<li>SMTP一般不使用中间邮件服务器发送邮件；</li>
<li>接收端的邮件服务器在没有运行的情况下，发送报文会被保留在发送端并等待进行新的尝试，不会在中间的服务器做停留。</li>
</ol>
<p>:::</p>
<h3 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a>与HTTP的对比</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li>HTTP和SMTP都是用于从一台主机向另一台主机传送文件；</li>
<li><del>持续的HTTP和SMTP都使用持续连接</del>（感觉像是废话……）</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol>
<li>HTTP用于从Web服务器向Web客户（例如浏览器）传送对象（例如文件），而SMTP用于从一个邮件服务器向另一个邮件服务器传送文件；</li>
<li>HTTP主要是一种<strong>拉协议（pull protocol）</strong>，在方便的时候，用户可以使用HTTP从某个Web服务器拉取一些被装载的信息；SMTP主要是一种<strong>推协议（push protocol）</strong>，发送邮件的服务器把文件推向接收邮件的服务器，当二者需要建立TCP连接时，发送邮件的服务器必须为建立连接的发起者。</li>
<li>SMTP要求每个报文采用7比特ASCII码格式，HTTP则不受限制；</li>
<li>在处理包含文本和图形的文档时，HTTP将每个对象封装到对应的不同响应报文中（就是一对一封装），SMTP将所有的对象放在一个报文中。</li>
</ol>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>不赘述，看看图就行</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409115819761.png" class="" title="image-20240409115819761">

<p>From和To是必须要有的</p>
<p>后面可能只有一个Subject首部行，也可能有其他多个可选的首部行</p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>目前流行的邮件访问协议：<strong>第三版邮局协议（Post Office Protocol–Version 3，POP3）</strong>，<strong>因特网邮件访问协议（Internet Mail Access Protocol，IMAP）</strong>，<strong>HTTP</strong></p>
<h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>主机识别有两种方式：主机名和IP地址。用户一般偏好主机名，而路由器则偏好IP地址。为了折中两种不同的偏好，域名系统应运而生。</p>
<p><strong>域名系统（Domain Name System，DNS）</strong>：==一个由分层的DNS服务器实现的分布式数据库和一个使得主机能够查询分布式数据库的应用层协议。==DNS协议运行在UDP之上，使用53端口</p>
<p>以<code>http://www.example.com/path/to/sth</code>举例，看看用户主机如何获取URL的IP地址：</p>
<ol>
<li>某台用户主机上运行着DNS应用的客户端；</li>
<li>浏览器从该URL抽出主机名<code>www.example.com</code>，并将其传递给DNS应用的客户端；</li>
<li>DNS客户向DNS服务器发送一个包含主机名的请求；</li>
<li>DNS客户最终收到一份回答报文，报文包含对应于主机名的IP地址；</li>
<li>浏览器在接收到来自DNS的IP地址后，就向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接</li>
</ol>
<p>除了进行主机名向IP地址转换外，DNS还提供其他一些重要服务：</p>
<h4 id="主机别名（host-aliasing）"><a href="#主机别名（host-aliasing）" class="headerlink" title="主机别名（host aliasing）"></a>主机别名（host aliasing）</h4><p>有的主机名长且复杂，原先的主机名叫<strong>规范主机名（canonical hostname）</strong>。为了方便记忆，这些主机都会有一个或多个<strong>主机别名</strong>。应用程序可以调用DNS来获得主机别名、对应的规范主机名和IP地址</p>
<h4 id="邮件服务器别名（mail-server-aliasing）"><a href="#邮件服务器别名（mail-server-aliasing）" class="headerlink" title="邮件服务器别名（mail server aliasing）"></a>邮件服务器别名（mail server aliasing）</h4><p>跟主机别名差不多，不赘述。</p>
<h4 id="负载分配（load-distribution）"><a href="#负载分配（load-distribution）" class="headerlink" title="负载分配（load distribution）"></a>负载分配（load distribution）</h4><p>此时的DNS用于冗余的服务器之间的负载分配。某个繁忙的站点被分布在多台服务器上，每台服务器运行在不同的端系统上，每个端系统都有不同的IP地址。这些冗余的服务器让一个IP地址集合与同一个规范主机名相联系，同时DNS数据库存储着这些IP地址的集合，因此当客户对映射到某地址集合的名字发出DNS请求，该服务器就用IP地址的整个集合进行响应，不过不同IP之间在响应时是有顺序的。</p>
<h3 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h3><p>这里就简单点说：</p>
<ol>
<li>用户主机的某应用程序需要将主机名转换为IP地址，调用DNS客户端，并指明需要被转换的主机名；</li>
<li>用户主机的DNS接收后向网络发送一个DNS查询报文；</li>
<li>经过一段时延后，用户主机上的DNS接收到一个提供希望映射的DNS回答报文；</li>
<li>映射结果传递到调用DNS的应用程序</li>
</ol>
<p>:::warning</p>
<p>所有的DNS请求和回答报文使用UDP数据报经过端口53发送</p>
<p>:::</p>
<h4 id="DNS的分布式设计"><a href="#DNS的分布式设计" class="headerlink" title="DNS的分布式设计"></a>DNS的分布式设计</h4><p>单一的DNS服务器虽然简单，但是出现的问题很多，包括但不限于：</p>
<ol>
<li><strong>单点故障（a single point of failure）</strong>：如果这个DNS服务器崩溃，那么整个因特网就会崩溃；</li>
<li><strong>通信容量（traffic volumn）</strong>：单个DNS服务器处理上亿个DNS查询显然不够；</li>
<li><strong>远距离的集中式数据库（distant centralized database）</strong>：单个DNS服务器是不可能位于所有用户的附近，若距离较远的用户向DNS服务器发送请求，那么可能会因为拥塞和低速的链路而导致很大的时延；</li>
<li><strong>维护（maintenance）</strong>：单个DNS服务必须要保留所有的因特网主机的记录，不仅会使数据库庞大，还需要为新主机的加入频繁更新。</li>
</ol>
<p>因此，DNS的分布式设计应运而生。</p>
<h5 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h5><p>为了解决扩展性问题，DNS使用了大量的DNS服务器，以层次方式组织，并且分布在全世界范围内。</p>
<p>这种方式一般有3种DNS服务器：==根DNS服务器，顶级域（Top-Level Domain，TLD）DNS服务器，权威DNS服务器。==</p>
<p>下图为部分DNS服务器的层次结构：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409153556448.png" class="" title="image-20240409153556448">

<p>除了以上服务器之外，还有一类重要的DNS服务器称为<strong>本地DNS服务器（local DNS server）</strong>，虽然它不属于层次结构里面的任何服务器，但是对层次结构十分重要。</p>
<p>一台主机如何得知另一台主机的IP地址呢？</p>
<p>举个例子：（请求主机设为A，目标主机设为B）</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409154512745.png" class="" title="image-20240409154512745">

<ol>
<li>主机A向它的本地DNS服务器发送一个DNS查询报文，报文包含了被转换的主机名B；</li>
<li>本地DNS服务器将报文转发给根DNS服务器；</li>
<li>根DNS服务器注意到主机A的edu前缀，然后向本地DNS服务器返回负责edu的TLD的IP地址列表；</li>
<li>本地DNS服务器再次向指定的TLD服务器之一发送报文；</li>
<li>TLD服务器注意到umass.edu的前缀，用权威DNS服务器的IP地址进行响应；</li>
<li>本地DNS服务器向权威DNS服务器重新发送报文；</li>
<li>权威DNS服务器用主机B的IP地址进行响应；</li>
<li>本地DNS服务器返回给主机A。</li>
</ol>
<p>这个步骤中总共发送了8篇报文。</p>
<p>:::info</p>
<p>上述例子利用了<strong>递归查询（recursive query）</strong>和<strong>迭代查询（iterative query）</strong>。</p>
<p>从主机到本地DNS服务器是递归查询，其余的均为迭代查询，因为所有的响应都是返回给本地DNS服务器的。</p>
<p>递归查询的例子如下图：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409160604713.png" class="" title="image-20240409160604713">

<p>这是不是就相当于之前学的递归呢，例如斐波那契额数列，调用函数本身，最终的结果是函数本身返回的值。</p>
<p>:::</p>
<h5 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h5><p>相当于在本地DNS服务器添加了一个DNS缓存器，用于存储每一个接收到的回答，可以绕过根服务器，便于请求主机在请求相同的地址时可以直接返回该IP地址，节省了时间，也节省了资源。</p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><h4 id="资源记录（Resource-Record，RR）"><a href="#资源记录（Resource-Record，RR）" class="headerlink" title="资源记录（Resource Record，RR）"></a>资源记录（Resource Record，RR）</h4><p>资源记录提供了主机名到IP地址的映射。每一个DNS回答报文包含了一条或多条资源记录。</p>
<p>资源记录包含了以下四元组：==（Name，Value，Type，TTL）==</p>
<p>TTL是记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name和Value取决于Type：</p>
<ol>
<li>Type=A，则Name就是主机名，Value就是主机名对应的IP地址；</li>
<li>Type=NS，则Name就是域名（如<code>example.com</code>），Value就是权威DNS服务器的主机名（如<code>dns.example.com</code>）；</li>
<li>Type=CNAME，则Name就是域名，Value是与之对应的规范主机名；</li>
<li>Type=MX，则Name就是域名，Value是与之对应的邮件服务器的规范主机名</li>
</ol>
<h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>以下是DNS报文格式：</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240409163119252.png" class="" title="image-20240409163119252">

<p>先说说前12个字节首部区域：</p>
<ol>
<li>标识符是16比特的数，用于标识该查询。该标识符会被复制到对应的回答报文中，以便匹配发送的请求和收到的回答；</li>
<li>标志字段有若干个标志，1比特的”查询/回答“标志位指出报文是查询（0）还是回答（1）；当请求的是权威DNS服务器时，1比特的”权威“标志位会置于回答报文中；</li>
<li>如果客户在DNS服务器没有某记录时想要递归查询，那么报文就会设置1比特的“希望标志”位；</li>
<li>如果DNS服务器支持递归查询，那么回答报文中把1比特的“递归可用”标志位进行置位；</li>
<li>另外四个有关数量的字段，则指出了在首部后的4类数据区域出现的数量</li>
</ol>
<p>再说说后面的数据区域：</p>
<ol>
<li><strong>问题区域</strong>包含正在进行的查询信息，包括：（1）名字字段，包含正在被查询的主机名；（2）类型字段，指出有关该名字的正被询问的问题类型，例如是否与一个名字（A）或一个名字的邮件服务器（MX）相关联；</li>
<li><strong>回答区域</strong>包含了对最初请求的名字的资源记录（上面已经说过，不记得的可以去翻翻看）。在回答报文中的回答区域中可以包含多条RR，因此一个主机名能够有多个IP地址；</li>
<li><strong>权威区域</strong>包含了其他权威服务器的记录；</li>
<li><strong>附加区域</strong>包含了其他有帮助的记录。例如，一个MX请求的回答报文的回答区域包含了一条资源记录，该记录提供了邮件服务器的规范主机名。该附加区域包含一个类型A记录，该记录提供了用于该邮件服务器的规范主机名的IP地址。</li>
</ol>
<p>:::info no-icon</p>
<p><strong>nslookup程序</strong>能够做到让正在工作的主机直接向某些DNS服务器发送一个DNS查询报文。</p>
<p>:::</p>
<h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><p>根据书上例子，假设服务器要将一个文件分发给一个固定的对等方集合，其中服务器与对等方使用接入链路与因特网相连，如下图所示</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240410151402082.png" class="" title="image-20240410151402082">

<p>设u<sub>s</sub>为服务器接入链路的上传速率，u<sub>i</sub>表示第i个对等方接入链路的上传速率，d<sub>i</sub>表示第i个对等方接入链路的下载速率，F表示被分发的文件长度（单位一般为bit），N表示对等方的数量，D<sub>cs</sub>是客户-服务器体系结构的分发时间。</p>
<p><strong>分发时间（distribution time）</strong>是所有N个对等方得到该文件的副本所需的时间。</p>
<p>为了排除影响，这里的环境假设为：因特网核心有足够的带宽（所以速率的瓶颈都在接入链路），服务器与客户没有参与任何其他网络应用（上传与下载的带宽能够全部用来发放该文件）</p>
<p>列出所求：</p>
<ol>
<li>由于服务器要传文件给N个对等方，因此上传文件的总量是NF bits，上传文件花费的总时间为NF / u<sub>s</sub>；</li>
<li>令d<sub>min</sub>表示所有对等方中最小的下载速率，因此d<sub>min</sub> = min{d<sub>1</sub>,d<sub>2</sub>,d<sub>3</sub>,……,d<sub>N</sub>}，这就导致有最小速率的对等方不能在F / d<sub>min</sub>内获取一个完整的文件，因此分发时间至少为F / d<sub>min</sub>；</li>
</ol>
<p>因此可以得到：</p>
<p>​                                                                                    ==D<sub>cs</sub> &gt;= max{NF / u<sub>s</sub>,F / d<sub>min</sub>}；==</p>
<p>不难看出，当N足够大时，客户-服务器分发时间就是由NF / u<sub>s</sub>来决定的。</p>
<p>接下来看一下P2P体系结构，条件不变，列出所求：</p>
<ol>
<li>开始分发时，由于只有服务器有文件，因此服务器至少要上传该文件1次，因此分发时间至少为F / u<sub>s</sub>（与前者有差别的是，服务器在分发一次文件后可以选择不用发送，因为该体系结构下可以通过其他对等方来分发该文件；</li>
<li>跟前者一样的是，有最小速率的对等方不能在F / d<sub>min</sub>内获取一个完整的文件，因此分发时间至少为F / d<sub>min</sub>；</li>
<li>在该体系结构下，系统整体的总上传能力等于服务器的上传速率加每个对等方的上传速率，即u<sub>total</sub> = u<sub>1</sub> + u<sub>2</sub> + … + u<sub>N</sub>;</li>
</ol>
<p>综上，设D<sub>P2P</sub>为P2P体系结构下的最小分发时间，得到</p>
<p>​                                                                                ==D<sub>P2P</sub> = max{F / u<sub>s</sub>,F / d<sub>min</sub>,NF / (u<sub>s</sub> + u<sub>total</sub>)}==</p>
<p>下图是两个结构的分发时间的变化趋势</p>
<img src="/2024/03/26/ComputerInternet/Computer-Internet2/image-20240410154325767.png" class="" title="image-20240410154325767">
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></div>  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2024-03-10  <a class="commentCountImg" href="/2024/03/10/ComputerInternet/Computer-Internet/#comment-container"><span class="display-none-class">1f84a3c6c75b9a9cbe97c57b733acece</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="1f84a3c6c75b9a9cbe97c57b733acece">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>29 分钟  <i class="fas fa-pencil-alt"> </i>4.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/10/ComputerInternet/Computer-Internet/">计网学习笔记（1）</a></h1><div class="content"><p>:::info</p>
<p>前言概要：知识点是根据《计算机网络：自顶向下方法》来整理的，内容以及其顺序可能与其他书本有出入</p>
<p>这篇博客是根据每一节写出我认为可能会考到的点或者说是需要知道的点，所以仅供参考</p>
<p>:::</p>
<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="几个概念（这一部分浅浅地看看就行）"><a href="#几个概念（这一部分浅浅地看看就行）" class="headerlink" title="几个概念（这一部分浅浅地看看就行）"></a>几个概念（这一部分浅浅地看看就行）</h2><ol>
<li><p>主机（host）或端系统（end system）：因特网中互联的计算设备</p>
</li>
<li><p>通信链路（communication link）和分组交换机（packet switch）：连接因特网中不同主机或端系统的重要工具。</p>
</li>
</ol>
<p>其中，==链路的传输速率的单位为bit/s或bps==</p>
<ol start="3">
<li><p>==分组（packet）==：不同端系统之间在传输信息时，发送端将数据分段并为每段加上首部字节所形成的信息包。</p>
</li>
<li><p>路由器（router）和链路层交换机（link-layer switch）：分组交换机的两种主要类型。</p>
</li>
<li><p>路径（route或path）：在不同端系统之间，一个分组经历的一系列通信链路和分组交换机</p>
</li>
<li><p>==Internet Server Provider（ISP）==：因特网服务提供商</p>
</li>
<li><p>==协议（protocol）==：定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
</li>
</ol>
<p>因特网中两个重要的协议是TCP/IP协议（Transmission Control Protocol 传输控制协议/Internet Protocol 网际协议），IP协议定义了在路由器和端系统之间发送和接收的分组格式</p>
<ol start="8">
<li><p>分布式应用程序(distributed applicalion)：涉及多个相互交换数据的端系统的应用程序</p>
</li>
<li><p>套接字接口（socket interface）：规定一个主机的某个程序请求因特网向另一个主机的特定程序交付数据的方式的接口</p>
</li>
</ol>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>概念：将端系统物理连接到其边缘路由器的网格。</p>
<p>接入网一般有以下三类，且方式各不相同：</p>
<ol>
<li><p>家庭接入：采用数字用户线（DSL）、电缆、光纤到户（FTTP）、拨号、卫星等方式接入；</p>
</li>
<li><p>企业接入：采用以太网和WiFi接入；</p>
</li>
<li><p>广域无线接入：采用第N代无线通信技术（我们常说的4G、5G）和LTE（长期演进）接入</p>
</li>
</ol>
<h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><p>可以类比于我们物理所学的介质，一般分为导引型媒体和非导引型媒体。</p>
<p>导引型媒体一般为固体，比较有代表性的媒体有双绞铜线、同轴电缆、光纤、陆地无线电信道、卫星无线电信道等。</p>
<p>非导引型媒体一般为空气或其他抽象物体，比较有代表性的媒体有无线局域网（WLAN）或数字卫星频道等。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>报文（message）：包含协议设计者所需的一切东西。它可以包含数据，也可以执行一种控制功能。</p>
<p>概念：端系统彼此交换报文。发送端系统将报文分成若干个较小的数据块（就是我们所说的分组），然后每个分组通过通信链路和分组交换机传送。</p>
<h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><p>概念：交换机在能够向输出链路传输某个分组的第一个比特之前，必须要接收整个分组。</p>
<p>就是说，发送端在向接收端传输一个分组时，接收端会将先到达的比特（分组的一部分）储存在缓存区，等到整个分组到达后，接收端才会向出链路传递这个分组</p>
<p>假设传输速率为R bps，两端之间的距离为L，那么接收端接收到整个分组所需的时间为 <code>L/R</code> s</p>
<p>如果接收端是路由器，两端分别是发送端和接收端</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324153633727.png" class="" title="image-20240324153633727">

<p>发送端想要发送4个分组给接收端</p>
<ol>
<li><p><code>d = 0 s</code>时，发送端开始发送分组；</p>
</li>
<li><p><code>d = L/R s</code>时，路由器完成接收第一个分组，并开始向接收端发送该分组，同时发送端开始发送第二个分组；</p>
</li>
<li><p><code>d = 2L/R s</code>时，接收端完成接收第一个分组，路由器完成接收第二个分组并开始发送该分组，同时发送端开始发送第三个分组；</p>
<p>……</p>
</li>
</ol>
<p>以此类推，当<code>d = 5L/R s</code>时，接收端完成接收所有分组</p>
<p>在这种情况下，端到端的时延为d_端到端 = <code>L/R s</code></p>
<p>一般在按照上述逻辑的情况下，分组在通过由N条速率均为R的链路组成的路径时，端到端的时延是</p>
<p>​                                                                                d_端到端 = <code>(N * L)/R</code></p>
<h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>输出缓存（output buffer，也叫输出队列）：用于存储路由器准备发往某条链路的分组；</p>
<p>排队时延（queuing delay）：从进入输出缓存等待到发送的这一段时间。产生的原因是传输的链路正忙于传输其他分组。它的大小取决于网络的拥塞程度；</p>
<p>分组丢失（丢包，pocket loss）：输出缓存已经被正在排队的分组给填满，会出现排队中的分组之一或到达的分组被丢弃的状况</p>
<h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>转发表（forwarding table）：用于将目的地址映射为输出链路。</p>
<p>每个路由器都具有一个转发表，某分组到达某台路由器时，该路由器会检查目的地址，并用这个地址搜索其转发表，用于发现适当的输出链路。</p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>若交换数据采用这个方式时，当两个端系统进行数据交换的时候，端系统与端系统之间会建立一条端到端的连接。沿着发送方和接收方这条路径上的交换机都将为该连接维护连接状态。</p>
<p>:::info no-icon</p>
<p>只说概念有点抽象，这里举一个经典的例子</p>
<p>传统的电话网络：建立二者之间的连接（占用通信资源）-&gt; 通话（持续占用通信资源） -&gt; 挂断电话，释放连接（归还通信资源）</p>
<p>:::</p>
<p>上述例子表明，端到端之间在传输信息之前会先建立一条连接，然后两端之间路径上的交换机会维持连接状态（占用一定数量的带宽），结束后会将占用带宽归还。</p>
<h4 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a>电路交换网络中的复用</h4><h5 id="频分复用（Frequency-Division-Multiplexing，FDM）"><a href="#频分复用（Frequency-Division-Multiplexing，FDM）" class="headerlink" title="频分复用（Frequency-Division Multiplexing，FDM）"></a>频分复用（Frequency-Division Multiplexing，FDM）</h5><p><del>书上说的读不太懂，不知道是不是翻译问题</del>。大概总结一下，就是==用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带==。</p>
<p>（书上说的是：链路的频谱由跨越链路创建的所有连接共享。特别是，在连接期间链路为每条连接专用一个频段）</p>
<p>下图则是FDM的图示，各路信号在同样的时间占用不同的带宽（这里指的是频带宽度而不是不是数据传输速率）</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324161809880.png" class="" title="image-20240324161809880">

<p>咱之前听收音机或者在坐车时，收听的广播就是用频分复用的方式来给我们传递信息的</p>
<h5 id="时分复用（Time-Devision-Multiplexing，TDM）"><a href="#时分复用（Time-Devision-Multiplexing，TDM）" class="headerlink" title="时分复用（Time-Devision Multiplexing，TDM）"></a>时分复用（Time-Devision Multiplexing，TDM）</h5><p>在这条链路中，时间会被等分为一段段TDM帧，每一段帧又会被划分出相同且固定的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。</p>
<p>下图是TDM的图示，序号2则是指定传输数据的专用时隙，周期为一个帧的长度。</p>
<p>在计算TDM传输速率时，若每秒传输2000帧，一个时隙大小是8bit，则传输速率为16kbps</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324162936954.png" class="" title="image-20240324162936954">

<p>:::danger no-icon 分组交换和电路交换的区别</p>
<ol>
<li><p>分组交换不会预留端系统之间沿路径通信所需的资源（如缓存，链路传输速率），电路交换会预留；</p>
</li>
<li><p>分组交换无需建立连接，电路交换需要建立连接；</p>
</li>
<li><p>分组交换会将报文分成若干个分组，通信链路只会在传输一个分组时被占用，利用率高；</p>
<p>电路交换会占用通信链路直到整段报文传输结束，利用率低；</p>
</li>
<li><p>分组交换在传输大数据时效率低，且容易丢包；</p>
<p>电路交换可以建立连接，数据传输稳定，效率高，适用于系统间高质量的大数据传输</p>
</li>
</ol>
<p>:::</p>
<h3 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h3>

<p>这个倒是没啥可说的，直接上图</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324165238018.png" class="" title="image-20240324165238018">

<p>接入ISP被称为<strong>客户</strong>；</p>
<p>==IXP（Internet Exchange Point）是因特网交接点==，作用是可以使多个ISP对等，对等的目的是直接将若干个ISP网络连接到一起，这样可以减少对第三方提供商的依赖，减少了数据传输成本</p>
<p>除了第一层，客户与其他ISP可以选择多个ISP连接，这样可以在一个ISP无法正常运作的情况下，客户与其他ISP仍然能正常进行数据交换</p>
<h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h3><p>==几个重要的时延==：节点处理时延(nodal processing delay)、 排队时延(queuing delay)、传输时延(transmission delay)、传播时延(propagation delay)</p>
<p>这几种时延加起来就是==节点总时延（total nodal delay）==</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324170527337.png" class="" title="image-20240324170527337">

<p>==一个类比来表明传输时延和传播时延的区别：前者指的是声音从嗓子到嘴巴这一段所需的时间，后者则是从一处传到另一处时，另一处完全接收到声音所需的时间==</p>
<p>:::warning</p>
<p>处理时延是以微秒或者更低的数量级作为单位，排队时延是以毫秒或微秒作为单位，传输时延和传播时延是以毫秒为作为单位</p>
<p>因此在计算的时候一定要注意单位，如果题目无说明，那么时延计算出秒时就要警惕起来（umm，总时延除外？）</p>
<p>:::</p>
<p>令d<sub>proc</sub>、d<sub>queue</sub>、d<sub>trans</sub>、d<sub>prop</sub>来表示处理时延、排队时延、传输时延、传播时延，那么节点总时延为：</p>
<p>​                                                            ==d<sub>nodal</sub> = d<sub>proc</sub>+d<sub>queue</sub>+d<sub>trans</sub>+d<sub>prop</sub>==</p>
<h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><p>省流：==设计系统时流量强度不能大于1==</p>
<p>令a表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s），R是从队列中推出比特的速率（相当于传输速率，以bps为单位），所有分组都是由L bits组成的，队列非常大（能容纳无限数量的bit）则比特到达队列的平均速率是La bps，比率<code>La/R</code>被称为流量强度（traffic intensity）。</p>
<p>当<code>La &gt; R</code>时，比特到达队列的平均速率大于传输速率，如此下去会使排队队列趋近于无穷大，进而导致排队时延无限大</p>
<p>（可以类比于公路上行驶的车辆，若单位时间内进入公路的汽车大于离开公路的汽车，则会导致车辆队列慢慢建立起来，最后导致拥堵）</p>
<p>当<code>0 &lt; La &lt;= R</code>时，平均排队时延和流量强度的关系如下图</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324175059657.png" class="" title="image-20240324175059657">

<p>由于排队容量有限，所以当排队序列被充满后，路由器会将后面到来的分组丢弃掉，这就是常说的丢包</p>
<h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><p>用d<sub>end-end</sub>表示，则</p>
<p>​                                                                            d<sub>end-end</sub> = N * (d<sub>proc</sub>+d<sub>trans</sub>+d<sub>prop</sub>)</p>
<p>N是指链路数，那么这一传递过程中有N-1个路由器</p>
<p>这个式子是d<sub>端到端</sub> = (N * L)/R的一般形式</p>
<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><p>这个没啥好说的，理解瞬时吞吐量和平均吞吐量就行</p>
<p>如果数据在传输中会经过不同链路，且不同链路速度不同，则其传输速率按最小的那一个来算（瓶颈链路）</p>
<h2 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h2><h3 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h3><h4 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h4><p>网络设计者以<strong>分层</strong>的形式组织协议和实现这些协议的网络硬件和软件，即每一层的服务模型</p>
<p>各层的所有协议称为==协议栈==。</p>
<p>因特网的协议栈自顶向下为：==应用层，运输层，网络层，管理层，物理层==</p>
<p>ISO OSI参考模型为：==应用层，表示层，会话层，运输层，网络层，管理层，物理层==</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324222649539.png" class="" title="image-20240324222649539">

<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>应用层是==网络应用程序和它们的应用层协议留存的地方==。</p>
<p>应用层包含了许多协议，如==HTTP（提供Web请求和文档的传送，SMTP（提供电子邮件报文的传送），FTP（提供两个段系统之间的文件传送）==</p>
<p>位于应用层的信息分组称为<strong>报文</strong></p>
<h5 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h5><p>运输层==在应用程序端点之间传送应用层报文==。</p>
<p>运输层也包含着协议，如TCP和UDP，前者提供面向连接的服务，后者提供无连接服务。我们只要选其中一个就可以运输应用层报文。</p>
<p>位于应用层的信息分组称为<strong>报文段</strong></p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>网络层==负责将网络层分组从一台主机移动到另一台主机==。</p>
<p>网络层也包含着协议，如网际协议IP，它定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。</p>
<p>位于网络层的信息分组称为<strong>数据报</strong></p>
<h5 id="链路（管理）层"><a href="#链路（管理）层" class="headerlink" title="链路（管理）层"></a>链路（管理）层</h5><p>链路层==用于将分组从一个节点移动到路径上的下一个节点==。</p>
<p>链路层也包含着协议，如DOCSIS，它是关于以太网、WiFi和电缆接入网的协议。不过应用于链路层的协议决定着链路层提供的服务。</p>
<p>位于链路层的信息分组称为<strong>帧</strong></p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>物理层==将整个帧的一个个比特从一个节点移动到下一个节点==。</p>
<p>物理层也包含着协议，不过是关于如双绞铜线，同轴电缆等等</p>
<p>:::info</p>
<p>其实，从上述描述中就可以知道为什么是自顶向下的方法了，因为上一层的数据传输总是依赖着它下一层</p>
<p>传输数据的变化：报文 -&gt; 报文段 -&gt; 数据报 -&gt; 帧 -&gt; 比特</p>
<p>:::</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>[info]{.label .info}这里的说法将情况给简化了点</p>
<p>在发送端，一个应用层报文（M）被传送给运输层，运输层收到报文并附加上运输层的首部信息（H_1），于是乎应用层报文和运输层首部一起构成了<strong>运输层报文段</strong>。</p>
<p>然后首部将被接收端的运输层使用。运输层向网络层传递该报文段，网络层增加了如源和接收端系统地址等网络层首部信息（H_n），于是乎就生成了<strong>网络层数据报</strong>。</p>
<p>接着数据报被传递给链路层。链路层增加它自己的链路层首部信息并生成<strong>链路层帧</strong>。</p>
<p>照这样看来，每一层的一个分组具有两种类型的字段：==首部字段和有效载荷字段==，有效载荷字段一般来源于上一层的分组</p>
<img src="/2024/03/10/ComputerInternet/Computer-Internet/image-20240324223837088.png" class="" title="image-20240324223837088">
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></div>  <hr></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/LUFFY.jpg" alt="Ins0mn1a"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ins0mn1a</p><p class="is-size-6 is-block">怎么才能睡个好觉呢？</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guiyang!!!</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Luffys93" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Luffys93"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1725237709@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-31T06:47:39.000Z">2024-07-31</time></p><p class="title"><a href="/2024/07/31/friend/index/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-29T05:34:18.859Z">2024-07-29</time></p><p class="title"><a href="/2024/07/29/hello-world/">Hello World</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-03T07:58:06.000Z">2024-07-03</time></p><p class="title"><a href="/2024/07/03/Webbbb/Others/Shell/">学习web安全的那些二三事-反弹Shell篇</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-27T05:54:49.000Z">2024-06-27</time></p><p class="title"><a href="/2024/06/27/Webbbb/linux/linux-second/">linux-second</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-25T08:20:52.000Z">2024-06-25</time></p><p class="title"><a href="/2024/06/25/Webbbb/linux/linux-first/">学习web安全的那些二三事-linux篇（1）</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Scr1w%E5%B9%B3%E5%8F%B0/"><span class="level-start"><span class="level-item">Scr1w平台</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Vulhub/"><span class="level-start"><span class="level-item">Vulhub</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/buu%E5%B9%B3%E5%8F%B0/"><span class="level-start"><span class="level-item">buu平台</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%AF%94%E8%B5%9B/"><span class="level-start"><span class="level-item">比赛</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%BD%91/"><span class="level-start"><span class="level-item">计网</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">INSOMNIA.__逃离失眠__</a><p class="size-small"><span>&copy; 2024 Ins0mn1a</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于各位师傅与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2024/7/29 21:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="9422021582" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('Ov23liIz1bPooLBfW0Cm','8f8f49427fa732912dade765d516294e964b4f41','LuffyS93','Comments_of_blog',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('Ov23liIz1bPooLBfW0Cm','8f8f49427fa732912dade765d516294e964b4f41','LuffyS93','Comments_of_blog',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>